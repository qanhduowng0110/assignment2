// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"entdemo/ent/apirequestlog"
	"entdemo/ent/associatedevent"
	"entdemo/ent/earthquake"
	"entdemo/ent/eventtype"
	"entdemo/ent/featuretype"
	"entdemo/ent/feltreport"
	"entdemo/ent/geometry"
	"entdemo/ent/predicate"
	"entdemo/ent/schemamigration"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIRequestLog   = "APIRequestLog"
	TypeAssociatedEvent = "AssociatedEvent"
	TypeEarthquake      = "Earthquake"
	TypeEarthquakeDb    = "Earthquake_db"
	TypeEventType       = "EventType"
	TypeFeatureType     = "FeatureType"
	TypeFeltReport      = "FeltReport"
	TypeGeometry        = "Geometry"
	TypeSchemaMigration = "SchemaMigration"
)

// APIRequestLogMutation represents an operation that mutates the APIRequestLog nodes in the graph.
type APIRequestLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	request_datetime   *time.Time
	request_parameters *map[string]interface{}
	request_body       *map[string]interface{}
	request_headers    *map[string]interface{}
	request_metadata   *map[string]interface{}
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*APIRequestLog, error)
	predicates         []predicate.APIRequestLog
}

var _ ent.Mutation = (*APIRequestLogMutation)(nil)

// apirequestlogOption allows management of the mutation configuration using functional options.
type apirequestlogOption func(*APIRequestLogMutation)

// newAPIRequestLogMutation creates new mutation for the APIRequestLog entity.
func newAPIRequestLogMutation(c config, op Op, opts ...apirequestlogOption) *APIRequestLogMutation {
	m := &APIRequestLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIRequestLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIRequestLogID sets the ID field of the mutation.
func withAPIRequestLogID(id int) apirequestlogOption {
	return func(m *APIRequestLogMutation) {
		var (
			err   error
			once  sync.Once
			value *APIRequestLog
		)
		m.oldValue = func(ctx context.Context) (*APIRequestLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIRequestLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIRequestLog sets the old APIRequestLog of the mutation.
func withAPIRequestLog(node *APIRequestLog) apirequestlogOption {
	return func(m *APIRequestLogMutation) {
		m.oldValue = func(context.Context) (*APIRequestLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIRequestLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIRequestLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIRequestLog entities.
func (m *APIRequestLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIRequestLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIRequestLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIRequestLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestDatetime sets the "request_datetime" field.
func (m *APIRequestLogMutation) SetRequestDatetime(t time.Time) {
	m.request_datetime = &t
}

// RequestDatetime returns the value of the "request_datetime" field in the mutation.
func (m *APIRequestLogMutation) RequestDatetime() (r time.Time, exists bool) {
	v := m.request_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestDatetime returns the old "request_datetime" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldRequestDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestDatetime: %w", err)
	}
	return oldValue.RequestDatetime, nil
}

// ResetRequestDatetime resets all changes to the "request_datetime" field.
func (m *APIRequestLogMutation) ResetRequestDatetime() {
	m.request_datetime = nil
}

// SetRequestParameters sets the "request_parameters" field.
func (m *APIRequestLogMutation) SetRequestParameters(value map[string]interface{}) {
	m.request_parameters = &value
}

// RequestParameters returns the value of the "request_parameters" field in the mutation.
func (m *APIRequestLogMutation) RequestParameters() (r map[string]interface{}, exists bool) {
	v := m.request_parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestParameters returns the old "request_parameters" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldRequestParameters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestParameters: %w", err)
	}
	return oldValue.RequestParameters, nil
}

// ResetRequestParameters resets all changes to the "request_parameters" field.
func (m *APIRequestLogMutation) ResetRequestParameters() {
	m.request_parameters = nil
}

// SetRequestBody sets the "request_body" field.
func (m *APIRequestLogMutation) SetRequestBody(value map[string]interface{}) {
	m.request_body = &value
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *APIRequestLogMutation) RequestBody() (r map[string]interface{}, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldRequestBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *APIRequestLogMutation) ResetRequestBody() {
	m.request_body = nil
}

// SetRequestHeaders sets the "request_headers" field.
func (m *APIRequestLogMutation) SetRequestHeaders(value map[string]interface{}) {
	m.request_headers = &value
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *APIRequestLogMutation) RequestHeaders() (r map[string]interface{}, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldRequestHeaders(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *APIRequestLogMutation) ResetRequestHeaders() {
	m.request_headers = nil
}

// SetRequestMetadata sets the "request_metadata" field.
func (m *APIRequestLogMutation) SetRequestMetadata(value map[string]interface{}) {
	m.request_metadata = &value
}

// RequestMetadata returns the value of the "request_metadata" field in the mutation.
func (m *APIRequestLogMutation) RequestMetadata() (r map[string]interface{}, exists bool) {
	v := m.request_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMetadata returns the old "request_metadata" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldRequestMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMetadata: %w", err)
	}
	return oldValue.RequestMetadata, nil
}

// ResetRequestMetadata resets all changes to the "request_metadata" field.
func (m *APIRequestLogMutation) ResetRequestMetadata() {
	m.request_metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *APIRequestLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIRequestLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIRequestLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIRequestLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIRequestLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIRequestLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIRequestLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIRequestLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIRequestLog entity.
// If the APIRequestLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIRequestLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APIRequestLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apirequestlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APIRequestLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apirequestlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIRequestLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apirequestlog.FieldDeletedAt)
}

// Where appends a list predicates to the APIRequestLogMutation builder.
func (m *APIRequestLogMutation) Where(ps ...predicate.APIRequestLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIRequestLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIRequestLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIRequestLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIRequestLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIRequestLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIRequestLog).
func (m *APIRequestLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIRequestLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.request_datetime != nil {
		fields = append(fields, apirequestlog.FieldRequestDatetime)
	}
	if m.request_parameters != nil {
		fields = append(fields, apirequestlog.FieldRequestParameters)
	}
	if m.request_body != nil {
		fields = append(fields, apirequestlog.FieldRequestBody)
	}
	if m.request_headers != nil {
		fields = append(fields, apirequestlog.FieldRequestHeaders)
	}
	if m.request_metadata != nil {
		fields = append(fields, apirequestlog.FieldRequestMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, apirequestlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apirequestlog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apirequestlog.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIRequestLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apirequestlog.FieldRequestDatetime:
		return m.RequestDatetime()
	case apirequestlog.FieldRequestParameters:
		return m.RequestParameters()
	case apirequestlog.FieldRequestBody:
		return m.RequestBody()
	case apirequestlog.FieldRequestHeaders:
		return m.RequestHeaders()
	case apirequestlog.FieldRequestMetadata:
		return m.RequestMetadata()
	case apirequestlog.FieldCreatedAt:
		return m.CreatedAt()
	case apirequestlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case apirequestlog.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIRequestLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apirequestlog.FieldRequestDatetime:
		return m.OldRequestDatetime(ctx)
	case apirequestlog.FieldRequestParameters:
		return m.OldRequestParameters(ctx)
	case apirequestlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case apirequestlog.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case apirequestlog.FieldRequestMetadata:
		return m.OldRequestMetadata(ctx)
	case apirequestlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apirequestlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apirequestlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIRequestLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIRequestLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apirequestlog.FieldRequestDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestDatetime(v)
		return nil
	case apirequestlog.FieldRequestParameters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestParameters(v)
		return nil
	case apirequestlog.FieldRequestBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case apirequestlog.FieldRequestHeaders:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case apirequestlog.FieldRequestMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMetadata(v)
		return nil
	case apirequestlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apirequestlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apirequestlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIRequestLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIRequestLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIRequestLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIRequestLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIRequestLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIRequestLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apirequestlog.FieldDeletedAt) {
		fields = append(fields, apirequestlog.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIRequestLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIRequestLogMutation) ClearField(name string) error {
	switch name {
	case apirequestlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown APIRequestLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIRequestLogMutation) ResetField(name string) error {
	switch name {
	case apirequestlog.FieldRequestDatetime:
		m.ResetRequestDatetime()
		return nil
	case apirequestlog.FieldRequestParameters:
		m.ResetRequestParameters()
		return nil
	case apirequestlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case apirequestlog.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case apirequestlog.FieldRequestMetadata:
		m.ResetRequestMetadata()
		return nil
	case apirequestlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apirequestlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apirequestlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown APIRequestLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIRequestLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIRequestLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIRequestLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIRequestLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIRequestLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIRequestLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIRequestLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown APIRequestLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIRequestLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown APIRequestLog edge %s", name)
}

// AssociatedEventMutation represents an operation that mutates the AssociatedEvent nodes in the graph.
type AssociatedEventMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int32
	clearedFields                      map[string]struct{}
	main_event_earthquake              *int32
	clearedmain_event_earthquake       bool
	associated_event_earthquake        *int32
	clearedassociated_event_earthquake bool
	done                               bool
	oldValue                           func(context.Context) (*AssociatedEvent, error)
	predicates                         []predicate.AssociatedEvent
}

var _ ent.Mutation = (*AssociatedEventMutation)(nil)

// associatedeventOption allows management of the mutation configuration using functional options.
type associatedeventOption func(*AssociatedEventMutation)

// newAssociatedEventMutation creates new mutation for the AssociatedEvent entity.
func newAssociatedEventMutation(c config, op Op, opts ...associatedeventOption) *AssociatedEventMutation {
	m := &AssociatedEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAssociatedEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssociatedEventID sets the ID field of the mutation.
func withAssociatedEventID(id int32) associatedeventOption {
	return func(m *AssociatedEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AssociatedEvent
		)
		m.oldValue = func(ctx context.Context) (*AssociatedEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssociatedEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssociatedEvent sets the old AssociatedEvent of the mutation.
func withAssociatedEvent(node *AssociatedEvent) associatedeventOption {
	return func(m *AssociatedEventMutation) {
		m.oldValue = func(context.Context) (*AssociatedEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssociatedEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssociatedEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssociatedEvent entities.
func (m *AssociatedEventMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssociatedEventMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssociatedEventMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssociatedEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *AssociatedEventMutation) SetEarthquakeID(i int32) {
	m.associated_event_earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *AssociatedEventMutation) EarthquakeID() (r int32, exists bool) {
	v := m.associated_event_earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the AssociatedEvent entity.
// If the AssociatedEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssociatedEventMutation) OldEarthquakeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *AssociatedEventMutation) ClearEarthquakeID() {
	m.associated_event_earthquake = nil
	m.clearedFields[associatedevent.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *AssociatedEventMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[associatedevent.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *AssociatedEventMutation) ResetEarthquakeID() {
	m.associated_event_earthquake = nil
	delete(m.clearedFields, associatedevent.FieldEarthquakeID)
}

// SetAssociateID sets the "associate_id" field.
func (m *AssociatedEventMutation) SetAssociateID(i int32) {
	m.main_event_earthquake = &i
}

// AssociateID returns the value of the "associate_id" field in the mutation.
func (m *AssociatedEventMutation) AssociateID() (r int32, exists bool) {
	v := m.main_event_earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldAssociateID returns the old "associate_id" field's value of the AssociatedEvent entity.
// If the AssociatedEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssociatedEventMutation) OldAssociateID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssociateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssociateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssociateID: %w", err)
	}
	return oldValue.AssociateID, nil
}

// ClearAssociateID clears the value of the "associate_id" field.
func (m *AssociatedEventMutation) ClearAssociateID() {
	m.main_event_earthquake = nil
	m.clearedFields[associatedevent.FieldAssociateID] = struct{}{}
}

// AssociateIDCleared returns if the "associate_id" field was cleared in this mutation.
func (m *AssociatedEventMutation) AssociateIDCleared() bool {
	_, ok := m.clearedFields[associatedevent.FieldAssociateID]
	return ok
}

// ResetAssociateID resets all changes to the "associate_id" field.
func (m *AssociatedEventMutation) ResetAssociateID() {
	m.main_event_earthquake = nil
	delete(m.clearedFields, associatedevent.FieldAssociateID)
}

// SetMainEventEarthquakeID sets the "main_event_earthquake" edge to the Earthquake entity by id.
func (m *AssociatedEventMutation) SetMainEventEarthquakeID(id int32) {
	m.main_event_earthquake = &id
}

// ClearMainEventEarthquake clears the "main_event_earthquake" edge to the Earthquake entity.
func (m *AssociatedEventMutation) ClearMainEventEarthquake() {
	m.clearedmain_event_earthquake = true
	m.clearedFields[associatedevent.FieldAssociateID] = struct{}{}
}

// MainEventEarthquakeCleared reports if the "main_event_earthquake" edge to the Earthquake entity was cleared.
func (m *AssociatedEventMutation) MainEventEarthquakeCleared() bool {
	return m.AssociateIDCleared() || m.clearedmain_event_earthquake
}

// MainEventEarthquakeID returns the "main_event_earthquake" edge ID in the mutation.
func (m *AssociatedEventMutation) MainEventEarthquakeID() (id int32, exists bool) {
	if m.main_event_earthquake != nil {
		return *m.main_event_earthquake, true
	}
	return
}

// MainEventEarthquakeIDs returns the "main_event_earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MainEventEarthquakeID instead. It exists only for internal usage by the builders.
func (m *AssociatedEventMutation) MainEventEarthquakeIDs() (ids []int32) {
	if id := m.main_event_earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMainEventEarthquake resets all changes to the "main_event_earthquake" edge.
func (m *AssociatedEventMutation) ResetMainEventEarthquake() {
	m.main_event_earthquake = nil
	m.clearedmain_event_earthquake = false
}

// SetAssociatedEventEarthquakeID sets the "associated_event_earthquake" edge to the Earthquake entity by id.
func (m *AssociatedEventMutation) SetAssociatedEventEarthquakeID(id int32) {
	m.associated_event_earthquake = &id
}

// ClearAssociatedEventEarthquake clears the "associated_event_earthquake" edge to the Earthquake entity.
func (m *AssociatedEventMutation) ClearAssociatedEventEarthquake() {
	m.clearedassociated_event_earthquake = true
	m.clearedFields[associatedevent.FieldEarthquakeID] = struct{}{}
}

// AssociatedEventEarthquakeCleared reports if the "associated_event_earthquake" edge to the Earthquake entity was cleared.
func (m *AssociatedEventMutation) AssociatedEventEarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedassociated_event_earthquake
}

// AssociatedEventEarthquakeID returns the "associated_event_earthquake" edge ID in the mutation.
func (m *AssociatedEventMutation) AssociatedEventEarthquakeID() (id int32, exists bool) {
	if m.associated_event_earthquake != nil {
		return *m.associated_event_earthquake, true
	}
	return
}

// AssociatedEventEarthquakeIDs returns the "associated_event_earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssociatedEventEarthquakeID instead. It exists only for internal usage by the builders.
func (m *AssociatedEventMutation) AssociatedEventEarthquakeIDs() (ids []int32) {
	if id := m.associated_event_earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssociatedEventEarthquake resets all changes to the "associated_event_earthquake" edge.
func (m *AssociatedEventMutation) ResetAssociatedEventEarthquake() {
	m.associated_event_earthquake = nil
	m.clearedassociated_event_earthquake = false
}

// Where appends a list predicates to the AssociatedEventMutation builder.
func (m *AssociatedEventMutation) Where(ps ...predicate.AssociatedEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssociatedEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssociatedEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssociatedEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssociatedEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssociatedEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssociatedEvent).
func (m *AssociatedEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssociatedEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.associated_event_earthquake != nil {
		fields = append(fields, associatedevent.FieldEarthquakeID)
	}
	if m.main_event_earthquake != nil {
		fields = append(fields, associatedevent.FieldAssociateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssociatedEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case associatedevent.FieldEarthquakeID:
		return m.EarthquakeID()
	case associatedevent.FieldAssociateID:
		return m.AssociateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssociatedEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case associatedevent.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case associatedevent.FieldAssociateID:
		return m.OldAssociateID(ctx)
	}
	return nil, fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssociatedEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case associatedevent.FieldAssociateID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssociateID(v)
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssociatedEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssociatedEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssociatedEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssociatedEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssociatedEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(associatedevent.FieldEarthquakeID) {
		fields = append(fields, associatedevent.FieldEarthquakeID)
	}
	if m.FieldCleared(associatedevent.FieldAssociateID) {
		fields = append(fields, associatedevent.FieldAssociateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssociatedEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssociatedEventMutation) ClearField(name string) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	case associatedevent.FieldAssociateID:
		m.ClearAssociateID()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssociatedEventMutation) ResetField(name string) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case associatedevent.FieldAssociateID:
		m.ResetAssociateID()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssociatedEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.main_event_earthquake != nil {
		edges = append(edges, associatedevent.EdgeMainEventEarthquake)
	}
	if m.associated_event_earthquake != nil {
		edges = append(edges, associatedevent.EdgeAssociatedEventEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssociatedEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case associatedevent.EdgeMainEventEarthquake:
		if id := m.main_event_earthquake; id != nil {
			return []ent.Value{*id}
		}
	case associatedevent.EdgeAssociatedEventEarthquake:
		if id := m.associated_event_earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssociatedEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssociatedEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssociatedEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmain_event_earthquake {
		edges = append(edges, associatedevent.EdgeMainEventEarthquake)
	}
	if m.clearedassociated_event_earthquake {
		edges = append(edges, associatedevent.EdgeAssociatedEventEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssociatedEventMutation) EdgeCleared(name string) bool {
	switch name {
	case associatedevent.EdgeMainEventEarthquake:
		return m.clearedmain_event_earthquake
	case associatedevent.EdgeAssociatedEventEarthquake:
		return m.clearedassociated_event_earthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssociatedEventMutation) ClearEdge(name string) error {
	switch name {
	case associatedevent.EdgeMainEventEarthquake:
		m.ClearMainEventEarthquake()
		return nil
	case associatedevent.EdgeAssociatedEventEarthquake:
		m.ClearAssociatedEventEarthquake()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssociatedEventMutation) ResetEdge(name string) error {
	switch name {
	case associatedevent.EdgeMainEventEarthquake:
		m.ResetMainEventEarthquake()
		return nil
	case associatedevent.EdgeAssociatedEventEarthquake:
		m.ResetAssociatedEventEarthquake()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent edge %s", name)
}

// EarthquakeMutation represents an operation that mutates the Earthquake nodes in the graph.
type EarthquakeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int32
	feature_id               *string
	magnitude                *float64
	addmagnitude             *float64
	occur_time               *time.Time
	update_time              *time.Time
	url                      *string
	detail_url               *string
	status                   *string
	tsunami                  *int32
	addtsunami               *int32
	sig                      *int32
	addsig                   *int32
	net                      *string
	code                     *string
	nst                      *int32
	addnst                   *int32
	dmin                     *float64
	adddmin                  *float64
	rms                      *float64
	addrms                   *float64
	gap                      *float64
	addgap                   *float64
	mag_type                 *string
	earthquake_type          *string
	clearedFields            map[string]struct{}
	main_events              map[int32]struct{}
	removedmain_events       map[int32]struct{}
	clearedmain_events       bool
	associated_events        map[int32]struct{}
	removedassociated_events map[int32]struct{}
	clearedassociated_events bool
	event_types              map[int32]struct{}
	removedevent_types       map[int32]struct{}
	clearedevent_types       bool
	feature_types            map[int32]struct{}
	removedfeature_types     map[int32]struct{}
	clearedfeature_types     bool
	felt_reports             map[int32]struct{}
	removedfelt_reports      map[int32]struct{}
	clearedfelt_reports      bool
	geometries               map[int32]struct{}
	removedgeometries        map[int32]struct{}
	clearedgeometries        bool
	done                     bool
	oldValue                 func(context.Context) (*Earthquake, error)
	predicates               []predicate.Earthquake
}

var _ ent.Mutation = (*EarthquakeMutation)(nil)

// earthquakeOption allows management of the mutation configuration using functional options.
type earthquakeOption func(*EarthquakeMutation)

// newEarthquakeMutation creates new mutation for the Earthquake entity.
func newEarthquakeMutation(c config, op Op, opts ...earthquakeOption) *EarthquakeMutation {
	m := &EarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarthquakeID sets the ID field of the mutation.
func withEarthquakeID(id int32) earthquakeOption {
	return func(m *EarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Earthquake
		)
		m.oldValue = func(ctx context.Context) (*Earthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Earthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarthquake sets the old Earthquake of the mutation.
func withEarthquake(node *Earthquake) earthquakeOption {
	return func(m *EarthquakeMutation) {
		m.oldValue = func(context.Context) (*Earthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Earthquake entities.
func (m *EarthquakeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarthquakeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarthquakeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Earthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatureID sets the "feature_id" field.
func (m *EarthquakeMutation) SetFeatureID(s string) {
	m.feature_id = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EarthquakeMutation) FeatureID() (r string, exists bool) {
	v := m.feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EarthquakeMutation) ResetFeatureID() {
	m.feature_id = nil
}

// SetMagnitude sets the "magnitude" field.
func (m *EarthquakeMutation) SetMagnitude(f float64) {
	m.magnitude = &f
	m.addmagnitude = nil
}

// Magnitude returns the value of the "magnitude" field in the mutation.
func (m *EarthquakeMutation) Magnitude() (r float64, exists bool) {
	v := m.magnitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMagnitude returns the old "magnitude" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMagnitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagnitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagnitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagnitude: %w", err)
	}
	return oldValue.Magnitude, nil
}

// AddMagnitude adds f to the "magnitude" field.
func (m *EarthquakeMutation) AddMagnitude(f float64) {
	if m.addmagnitude != nil {
		*m.addmagnitude += f
	} else {
		m.addmagnitude = &f
	}
}

// AddedMagnitude returns the value that was added to the "magnitude" field in this mutation.
func (m *EarthquakeMutation) AddedMagnitude() (r float64, exists bool) {
	v := m.addmagnitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetMagnitude resets all changes to the "magnitude" field.
func (m *EarthquakeMutation) ResetMagnitude() {
	m.magnitude = nil
	m.addmagnitude = nil
}

// SetOccurTime sets the "occur_time" field.
func (m *EarthquakeMutation) SetOccurTime(t time.Time) {
	m.occur_time = &t
}

// OccurTime returns the value of the "occur_time" field in the mutation.
func (m *EarthquakeMutation) OccurTime() (r time.Time, exists bool) {
	v := m.occur_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurTime returns the old "occur_time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldOccurTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurTime: %w", err)
	}
	return oldValue.OccurTime, nil
}

// ResetOccurTime resets all changes to the "occur_time" field.
func (m *EarthquakeMutation) ResetOccurTime() {
	m.occur_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EarthquakeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EarthquakeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EarthquakeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetURL sets the "url" field.
func (m *EarthquakeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EarthquakeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *EarthquakeMutation) ResetURL() {
	m.url = nil
}

// SetDetailURL sets the "detail_url" field.
func (m *EarthquakeMutation) SetDetailURL(s string) {
	m.detail_url = &s
}

// DetailURL returns the value of the "detail_url" field in the mutation.
func (m *EarthquakeMutation) DetailURL() (r string, exists bool) {
	v := m.detail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailURL returns the old "detail_url" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDetailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailURL: %w", err)
	}
	return oldValue.DetailURL, nil
}

// ResetDetailURL resets all changes to the "detail_url" field.
func (m *EarthquakeMutation) ResetDetailURL() {
	m.detail_url = nil
}

// SetStatus sets the "status" field.
func (m *EarthquakeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EarthquakeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EarthquakeMutation) ResetStatus() {
	m.status = nil
}

// SetTsunami sets the "tsunami" field.
func (m *EarthquakeMutation) SetTsunami(i int32) {
	m.tsunami = &i
	m.addtsunami = nil
}

// Tsunami returns the value of the "tsunami" field in the mutation.
func (m *EarthquakeMutation) Tsunami() (r int32, exists bool) {
	v := m.tsunami
	if v == nil {
		return
	}
	return *v, true
}

// OldTsunami returns the old "tsunami" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTsunami(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTsunami is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTsunami requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTsunami: %w", err)
	}
	return oldValue.Tsunami, nil
}

// AddTsunami adds i to the "tsunami" field.
func (m *EarthquakeMutation) AddTsunami(i int32) {
	if m.addtsunami != nil {
		*m.addtsunami += i
	} else {
		m.addtsunami = &i
	}
}

// AddedTsunami returns the value that was added to the "tsunami" field in this mutation.
func (m *EarthquakeMutation) AddedTsunami() (r int32, exists bool) {
	v := m.addtsunami
	if v == nil {
		return
	}
	return *v, true
}

// ResetTsunami resets all changes to the "tsunami" field.
func (m *EarthquakeMutation) ResetTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
}

// SetSig sets the "sig" field.
func (m *EarthquakeMutation) SetSig(i int32) {
	m.sig = &i
	m.addsig = nil
}

// Sig returns the value of the "sig" field in the mutation.
func (m *EarthquakeMutation) Sig() (r int32, exists bool) {
	v := m.sig
	if v == nil {
		return
	}
	return *v, true
}

// OldSig returns the old "sig" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldSig(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSig: %w", err)
	}
	return oldValue.Sig, nil
}

// AddSig adds i to the "sig" field.
func (m *EarthquakeMutation) AddSig(i int32) {
	if m.addsig != nil {
		*m.addsig += i
	} else {
		m.addsig = &i
	}
}

// AddedSig returns the value that was added to the "sig" field in this mutation.
func (m *EarthquakeMutation) AddedSig() (r int32, exists bool) {
	v := m.addsig
	if v == nil {
		return
	}
	return *v, true
}

// ResetSig resets all changes to the "sig" field.
func (m *EarthquakeMutation) ResetSig() {
	m.sig = nil
	m.addsig = nil
}

// SetNet sets the "net" field.
func (m *EarthquakeMutation) SetNet(s string) {
	m.net = &s
}

// Net returns the value of the "net" field in the mutation.
func (m *EarthquakeMutation) Net() (r string, exists bool) {
	v := m.net
	if v == nil {
		return
	}
	return *v, true
}

// OldNet returns the old "net" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNet: %w", err)
	}
	return oldValue.Net, nil
}

// ResetNet resets all changes to the "net" field.
func (m *EarthquakeMutation) ResetNet() {
	m.net = nil
}

// SetCode sets the "code" field.
func (m *EarthquakeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EarthquakeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *EarthquakeMutation) ResetCode() {
	m.code = nil
}

// SetNst sets the "nst" field.
func (m *EarthquakeMutation) SetNst(i int32) {
	m.nst = &i
	m.addnst = nil
}

// Nst returns the value of the "nst" field in the mutation.
func (m *EarthquakeMutation) Nst() (r int32, exists bool) {
	v := m.nst
	if v == nil {
		return
	}
	return *v, true
}

// OldNst returns the old "nst" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNst(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNst: %w", err)
	}
	return oldValue.Nst, nil
}

// AddNst adds i to the "nst" field.
func (m *EarthquakeMutation) AddNst(i int32) {
	if m.addnst != nil {
		*m.addnst += i
	} else {
		m.addnst = &i
	}
}

// AddedNst returns the value that was added to the "nst" field in this mutation.
func (m *EarthquakeMutation) AddedNst() (r int32, exists bool) {
	v := m.addnst
	if v == nil {
		return
	}
	return *v, true
}

// ResetNst resets all changes to the "nst" field.
func (m *EarthquakeMutation) ResetNst() {
	m.nst = nil
	m.addnst = nil
}

// SetDmin sets the "dmin" field.
func (m *EarthquakeMutation) SetDmin(f float64) {
	m.dmin = &f
	m.adddmin = nil
}

// Dmin returns the value of the "dmin" field in the mutation.
func (m *EarthquakeMutation) Dmin() (r float64, exists bool) {
	v := m.dmin
	if v == nil {
		return
	}
	return *v, true
}

// OldDmin returns the old "dmin" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDmin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDmin: %w", err)
	}
	return oldValue.Dmin, nil
}

// AddDmin adds f to the "dmin" field.
func (m *EarthquakeMutation) AddDmin(f float64) {
	if m.adddmin != nil {
		*m.adddmin += f
	} else {
		m.adddmin = &f
	}
}

// AddedDmin returns the value that was added to the "dmin" field in this mutation.
func (m *EarthquakeMutation) AddedDmin() (r float64, exists bool) {
	v := m.adddmin
	if v == nil {
		return
	}
	return *v, true
}

// ResetDmin resets all changes to the "dmin" field.
func (m *EarthquakeMutation) ResetDmin() {
	m.dmin = nil
	m.adddmin = nil
}

// SetRms sets the "rms" field.
func (m *EarthquakeMutation) SetRms(f float64) {
	m.rms = &f
	m.addrms = nil
}

// Rms returns the value of the "rms" field in the mutation.
func (m *EarthquakeMutation) Rms() (r float64, exists bool) {
	v := m.rms
	if v == nil {
		return
	}
	return *v, true
}

// OldRms returns the old "rms" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldRms(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRms: %w", err)
	}
	return oldValue.Rms, nil
}

// AddRms adds f to the "rms" field.
func (m *EarthquakeMutation) AddRms(f float64) {
	if m.addrms != nil {
		*m.addrms += f
	} else {
		m.addrms = &f
	}
}

// AddedRms returns the value that was added to the "rms" field in this mutation.
func (m *EarthquakeMutation) AddedRms() (r float64, exists bool) {
	v := m.addrms
	if v == nil {
		return
	}
	return *v, true
}

// ResetRms resets all changes to the "rms" field.
func (m *EarthquakeMutation) ResetRms() {
	m.rms = nil
	m.addrms = nil
}

// SetGap sets the "gap" field.
func (m *EarthquakeMutation) SetGap(f float64) {
	m.gap = &f
	m.addgap = nil
}

// Gap returns the value of the "gap" field in the mutation.
func (m *EarthquakeMutation) Gap() (r float64, exists bool) {
	v := m.gap
	if v == nil {
		return
	}
	return *v, true
}

// OldGap returns the old "gap" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGap(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGap: %w", err)
	}
	return oldValue.Gap, nil
}

// AddGap adds f to the "gap" field.
func (m *EarthquakeMutation) AddGap(f float64) {
	if m.addgap != nil {
		*m.addgap += f
	} else {
		m.addgap = &f
	}
}

// AddedGap returns the value that was added to the "gap" field in this mutation.
func (m *EarthquakeMutation) AddedGap() (r float64, exists bool) {
	v := m.addgap
	if v == nil {
		return
	}
	return *v, true
}

// ResetGap resets all changes to the "gap" field.
func (m *EarthquakeMutation) ResetGap() {
	m.gap = nil
	m.addgap = nil
}

// SetMagType sets the "mag_type" field.
func (m *EarthquakeMutation) SetMagType(s string) {
	m.mag_type = &s
}

// MagType returns the value of the "mag_type" field in the mutation.
func (m *EarthquakeMutation) MagType() (r string, exists bool) {
	v := m.mag_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMagType returns the old "mag_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMagType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagType: %w", err)
	}
	return oldValue.MagType, nil
}

// ResetMagType resets all changes to the "mag_type" field.
func (m *EarthquakeMutation) ResetMagType() {
	m.mag_type = nil
}

// SetEarthquakeType sets the "earthquake_type" field.
func (m *EarthquakeMutation) SetEarthquakeType(s string) {
	m.earthquake_type = &s
}

// EarthquakeType returns the value of the "earthquake_type" field in the mutation.
func (m *EarthquakeMutation) EarthquakeType() (r string, exists bool) {
	v := m.earthquake_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeType returns the old "earthquake_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldEarthquakeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeType: %w", err)
	}
	return oldValue.EarthquakeType, nil
}

// ResetEarthquakeType resets all changes to the "earthquake_type" field.
func (m *EarthquakeMutation) ResetEarthquakeType() {
	m.earthquake_type = nil
}

// AddMainEventIDs adds the "main_events" edge to the AssociatedEvent entity by ids.
func (m *EarthquakeMutation) AddMainEventIDs(ids ...int32) {
	if m.main_events == nil {
		m.main_events = make(map[int32]struct{})
	}
	for i := range ids {
		m.main_events[ids[i]] = struct{}{}
	}
}

// ClearMainEvents clears the "main_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) ClearMainEvents() {
	m.clearedmain_events = true
}

// MainEventsCleared reports if the "main_events" edge to the AssociatedEvent entity was cleared.
func (m *EarthquakeMutation) MainEventsCleared() bool {
	return m.clearedmain_events
}

// RemoveMainEventIDs removes the "main_events" edge to the AssociatedEvent entity by IDs.
func (m *EarthquakeMutation) RemoveMainEventIDs(ids ...int32) {
	if m.removedmain_events == nil {
		m.removedmain_events = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.main_events, ids[i])
		m.removedmain_events[ids[i]] = struct{}{}
	}
}

// RemovedMainEvents returns the removed IDs of the "main_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) RemovedMainEventsIDs() (ids []int32) {
	for id := range m.removedmain_events {
		ids = append(ids, id)
	}
	return
}

// MainEventsIDs returns the "main_events" edge IDs in the mutation.
func (m *EarthquakeMutation) MainEventsIDs() (ids []int32) {
	for id := range m.main_events {
		ids = append(ids, id)
	}
	return
}

// ResetMainEvents resets all changes to the "main_events" edge.
func (m *EarthquakeMutation) ResetMainEvents() {
	m.main_events = nil
	m.clearedmain_events = false
	m.removedmain_events = nil
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by ids.
func (m *EarthquakeMutation) AddAssociatedEventIDs(ids ...int32) {
	if m.associated_events == nil {
		m.associated_events = make(map[int32]struct{})
	}
	for i := range ids {
		m.associated_events[ids[i]] = struct{}{}
	}
}

// ClearAssociatedEvents clears the "associated_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) ClearAssociatedEvents() {
	m.clearedassociated_events = true
}

// AssociatedEventsCleared reports if the "associated_events" edge to the AssociatedEvent entity was cleared.
func (m *EarthquakeMutation) AssociatedEventsCleared() bool {
	return m.clearedassociated_events
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to the AssociatedEvent entity by IDs.
func (m *EarthquakeMutation) RemoveAssociatedEventIDs(ids ...int32) {
	if m.removedassociated_events == nil {
		m.removedassociated_events = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.associated_events, ids[i])
		m.removedassociated_events[ids[i]] = struct{}{}
	}
}

// RemovedAssociatedEvents returns the removed IDs of the "associated_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) RemovedAssociatedEventsIDs() (ids []int32) {
	for id := range m.removedassociated_events {
		ids = append(ids, id)
	}
	return
}

// AssociatedEventsIDs returns the "associated_events" edge IDs in the mutation.
func (m *EarthquakeMutation) AssociatedEventsIDs() (ids []int32) {
	for id := range m.associated_events {
		ids = append(ids, id)
	}
	return
}

// ResetAssociatedEvents resets all changes to the "associated_events" edge.
func (m *EarthquakeMutation) ResetAssociatedEvents() {
	m.associated_events = nil
	m.clearedassociated_events = false
	m.removedassociated_events = nil
}

// AddEventTypeIDs adds the "event_types" edge to the EventType entity by ids.
func (m *EarthquakeMutation) AddEventTypeIDs(ids ...int32) {
	if m.event_types == nil {
		m.event_types = make(map[int32]struct{})
	}
	for i := range ids {
		m.event_types[ids[i]] = struct{}{}
	}
}

// ClearEventTypes clears the "event_types" edge to the EventType entity.
func (m *EarthquakeMutation) ClearEventTypes() {
	m.clearedevent_types = true
}

// EventTypesCleared reports if the "event_types" edge to the EventType entity was cleared.
func (m *EarthquakeMutation) EventTypesCleared() bool {
	return m.clearedevent_types
}

// RemoveEventTypeIDs removes the "event_types" edge to the EventType entity by IDs.
func (m *EarthquakeMutation) RemoveEventTypeIDs(ids ...int32) {
	if m.removedevent_types == nil {
		m.removedevent_types = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.event_types, ids[i])
		m.removedevent_types[ids[i]] = struct{}{}
	}
}

// RemovedEventTypes returns the removed IDs of the "event_types" edge to the EventType entity.
func (m *EarthquakeMutation) RemovedEventTypesIDs() (ids []int32) {
	for id := range m.removedevent_types {
		ids = append(ids, id)
	}
	return
}

// EventTypesIDs returns the "event_types" edge IDs in the mutation.
func (m *EarthquakeMutation) EventTypesIDs() (ids []int32) {
	for id := range m.event_types {
		ids = append(ids, id)
	}
	return
}

// ResetEventTypes resets all changes to the "event_types" edge.
func (m *EarthquakeMutation) ResetEventTypes() {
	m.event_types = nil
	m.clearedevent_types = false
	m.removedevent_types = nil
}

// AddFeatureTypeIDs adds the "feature_types" edge to the FeatureType entity by ids.
func (m *EarthquakeMutation) AddFeatureTypeIDs(ids ...int32) {
	if m.feature_types == nil {
		m.feature_types = make(map[int32]struct{})
	}
	for i := range ids {
		m.feature_types[ids[i]] = struct{}{}
	}
}

// ClearFeatureTypes clears the "feature_types" edge to the FeatureType entity.
func (m *EarthquakeMutation) ClearFeatureTypes() {
	m.clearedfeature_types = true
}

// FeatureTypesCleared reports if the "feature_types" edge to the FeatureType entity was cleared.
func (m *EarthquakeMutation) FeatureTypesCleared() bool {
	return m.clearedfeature_types
}

// RemoveFeatureTypeIDs removes the "feature_types" edge to the FeatureType entity by IDs.
func (m *EarthquakeMutation) RemoveFeatureTypeIDs(ids ...int32) {
	if m.removedfeature_types == nil {
		m.removedfeature_types = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.feature_types, ids[i])
		m.removedfeature_types[ids[i]] = struct{}{}
	}
}

// RemovedFeatureTypes returns the removed IDs of the "feature_types" edge to the FeatureType entity.
func (m *EarthquakeMutation) RemovedFeatureTypesIDs() (ids []int32) {
	for id := range m.removedfeature_types {
		ids = append(ids, id)
	}
	return
}

// FeatureTypesIDs returns the "feature_types" edge IDs in the mutation.
func (m *EarthquakeMutation) FeatureTypesIDs() (ids []int32) {
	for id := range m.feature_types {
		ids = append(ids, id)
	}
	return
}

// ResetFeatureTypes resets all changes to the "feature_types" edge.
func (m *EarthquakeMutation) ResetFeatureTypes() {
	m.feature_types = nil
	m.clearedfeature_types = false
	m.removedfeature_types = nil
}

// AddFeltReportIDs adds the "felt_reports" edge to the FeltReport entity by ids.
func (m *EarthquakeMutation) AddFeltReportIDs(ids ...int32) {
	if m.felt_reports == nil {
		m.felt_reports = make(map[int32]struct{})
	}
	for i := range ids {
		m.felt_reports[ids[i]] = struct{}{}
	}
}

// ClearFeltReports clears the "felt_reports" edge to the FeltReport entity.
func (m *EarthquakeMutation) ClearFeltReports() {
	m.clearedfelt_reports = true
}

// FeltReportsCleared reports if the "felt_reports" edge to the FeltReport entity was cleared.
func (m *EarthquakeMutation) FeltReportsCleared() bool {
	return m.clearedfelt_reports
}

// RemoveFeltReportIDs removes the "felt_reports" edge to the FeltReport entity by IDs.
func (m *EarthquakeMutation) RemoveFeltReportIDs(ids ...int32) {
	if m.removedfelt_reports == nil {
		m.removedfelt_reports = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.felt_reports, ids[i])
		m.removedfelt_reports[ids[i]] = struct{}{}
	}
}

// RemovedFeltReports returns the removed IDs of the "felt_reports" edge to the FeltReport entity.
func (m *EarthquakeMutation) RemovedFeltReportsIDs() (ids []int32) {
	for id := range m.removedfelt_reports {
		ids = append(ids, id)
	}
	return
}

// FeltReportsIDs returns the "felt_reports" edge IDs in the mutation.
func (m *EarthquakeMutation) FeltReportsIDs() (ids []int32) {
	for id := range m.felt_reports {
		ids = append(ids, id)
	}
	return
}

// ResetFeltReports resets all changes to the "felt_reports" edge.
func (m *EarthquakeMutation) ResetFeltReports() {
	m.felt_reports = nil
	m.clearedfelt_reports = false
	m.removedfelt_reports = nil
}

// AddGeometryIDs adds the "geometries" edge to the Geometry entity by ids.
func (m *EarthquakeMutation) AddGeometryIDs(ids ...int32) {
	if m.geometries == nil {
		m.geometries = make(map[int32]struct{})
	}
	for i := range ids {
		m.geometries[ids[i]] = struct{}{}
	}
}

// ClearGeometries clears the "geometries" edge to the Geometry entity.
func (m *EarthquakeMutation) ClearGeometries() {
	m.clearedgeometries = true
}

// GeometriesCleared reports if the "geometries" edge to the Geometry entity was cleared.
func (m *EarthquakeMutation) GeometriesCleared() bool {
	return m.clearedgeometries
}

// RemoveGeometryIDs removes the "geometries" edge to the Geometry entity by IDs.
func (m *EarthquakeMutation) RemoveGeometryIDs(ids ...int32) {
	if m.removedgeometries == nil {
		m.removedgeometries = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.geometries, ids[i])
		m.removedgeometries[ids[i]] = struct{}{}
	}
}

// RemovedGeometries returns the removed IDs of the "geometries" edge to the Geometry entity.
func (m *EarthquakeMutation) RemovedGeometriesIDs() (ids []int32) {
	for id := range m.removedgeometries {
		ids = append(ids, id)
	}
	return
}

// GeometriesIDs returns the "geometries" edge IDs in the mutation.
func (m *EarthquakeMutation) GeometriesIDs() (ids []int32) {
	for id := range m.geometries {
		ids = append(ids, id)
	}
	return
}

// ResetGeometries resets all changes to the "geometries" edge.
func (m *EarthquakeMutation) ResetGeometries() {
	m.geometries = nil
	m.clearedgeometries = false
	m.removedgeometries = nil
}

// Where appends a list predicates to the EarthquakeMutation builder.
func (m *EarthquakeMutation) Where(ps ...predicate.Earthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Earthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Earthquake).
func (m *EarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.feature_id != nil {
		fields = append(fields, earthquake.FieldFeatureID)
	}
	if m.magnitude != nil {
		fields = append(fields, earthquake.FieldMagnitude)
	}
	if m.occur_time != nil {
		fields = append(fields, earthquake.FieldOccurTime)
	}
	if m.update_time != nil {
		fields = append(fields, earthquake.FieldUpdateTime)
	}
	if m.url != nil {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.detail_url != nil {
		fields = append(fields, earthquake.FieldDetailURL)
	}
	if m.status != nil {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.tsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.sig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.net != nil {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.code != nil {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.nst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.dmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.rms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.gap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.mag_type != nil {
		fields = append(fields, earthquake.FieldMagType)
	}
	if m.earthquake_type != nil {
		fields = append(fields, earthquake.FieldEarthquakeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldFeatureID:
		return m.FeatureID()
	case earthquake.FieldMagnitude:
		return m.Magnitude()
	case earthquake.FieldOccurTime:
		return m.OccurTime()
	case earthquake.FieldUpdateTime:
		return m.UpdateTime()
	case earthquake.FieldURL:
		return m.URL()
	case earthquake.FieldDetailURL:
		return m.DetailURL()
	case earthquake.FieldStatus:
		return m.Status()
	case earthquake.FieldTsunami:
		return m.Tsunami()
	case earthquake.FieldSig:
		return m.Sig()
	case earthquake.FieldNet:
		return m.Net()
	case earthquake.FieldCode:
		return m.Code()
	case earthquake.FieldNst:
		return m.Nst()
	case earthquake.FieldDmin:
		return m.Dmin()
	case earthquake.FieldRms:
		return m.Rms()
	case earthquake.FieldGap:
		return m.Gap()
	case earthquake.FieldMagType:
		return m.MagType()
	case earthquake.FieldEarthquakeType:
		return m.EarthquakeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earthquake.FieldFeatureID:
		return m.OldFeatureID(ctx)
	case earthquake.FieldMagnitude:
		return m.OldMagnitude(ctx)
	case earthquake.FieldOccurTime:
		return m.OldOccurTime(ctx)
	case earthquake.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case earthquake.FieldURL:
		return m.OldURL(ctx)
	case earthquake.FieldDetailURL:
		return m.OldDetailURL(ctx)
	case earthquake.FieldStatus:
		return m.OldStatus(ctx)
	case earthquake.FieldTsunami:
		return m.OldTsunami(ctx)
	case earthquake.FieldSig:
		return m.OldSig(ctx)
	case earthquake.FieldNet:
		return m.OldNet(ctx)
	case earthquake.FieldCode:
		return m.OldCode(ctx)
	case earthquake.FieldNst:
		return m.OldNst(ctx)
	case earthquake.FieldDmin:
		return m.OldDmin(ctx)
	case earthquake.FieldRms:
		return m.OldRms(ctx)
	case earthquake.FieldGap:
		return m.OldGap(ctx)
	case earthquake.FieldMagType:
		return m.OldMagType(ctx)
	case earthquake.FieldEarthquakeType:
		return m.OldEarthquakeType(ctx)
	}
	return nil, fmt.Errorf("unknown Earthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	case earthquake.FieldMagnitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagnitude(v)
		return nil
	case earthquake.FieldOccurTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurTime(v)
		return nil
	case earthquake.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case earthquake.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case earthquake.FieldDetailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailURL(v)
		return nil
	case earthquake.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSig(v)
		return nil
	case earthquake.FieldNet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNet(v)
		return nil
	case earthquake.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGap(v)
		return nil
	case earthquake.FieldMagType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagType(v)
		return nil
	case earthquake.FieldEarthquakeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeType(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarthquakeMutation) AddedFields() []string {
	var fields []string
	if m.addmagnitude != nil {
		fields = append(fields, earthquake.FieldMagnitude)
	}
	if m.addtsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.addsig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.addnst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.adddmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.addrms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.addgap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldMagnitude:
		return m.AddedMagnitude()
	case earthquake.FieldTsunami:
		return m.AddedTsunami()
	case earthquake.FieldSig:
		return m.AddedSig()
	case earthquake.FieldNst:
		return m.AddedNst()
	case earthquake.FieldDmin:
		return m.AddedDmin()
	case earthquake.FieldRms:
		return m.AddedRms()
	case earthquake.FieldGap:
		return m.AddedGap()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldMagnitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagnitude(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSig(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGap(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarthquakeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarthquakeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Earthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarthquakeMutation) ResetField(name string) error {
	switch name {
	case earthquake.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	case earthquake.FieldMagnitude:
		m.ResetMagnitude()
		return nil
	case earthquake.FieldOccurTime:
		m.ResetOccurTime()
		return nil
	case earthquake.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case earthquake.FieldURL:
		m.ResetURL()
		return nil
	case earthquake.FieldDetailURL:
		m.ResetDetailURL()
		return nil
	case earthquake.FieldStatus:
		m.ResetStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ResetTsunami()
		return nil
	case earthquake.FieldSig:
		m.ResetSig()
		return nil
	case earthquake.FieldNet:
		m.ResetNet()
		return nil
	case earthquake.FieldCode:
		m.ResetCode()
		return nil
	case earthquake.FieldNst:
		m.ResetNst()
		return nil
	case earthquake.FieldDmin:
		m.ResetDmin()
		return nil
	case earthquake.FieldRms:
		m.ResetRms()
		return nil
	case earthquake.FieldGap:
		m.ResetGap()
		return nil
	case earthquake.FieldMagType:
		m.ResetMagType()
		return nil
	case earthquake.FieldEarthquakeType:
		m.ResetEarthquakeType()
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.main_events != nil {
		edges = append(edges, earthquake.EdgeMainEvents)
	}
	if m.associated_events != nil {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.event_types != nil {
		edges = append(edges, earthquake.EdgeEventTypes)
	}
	if m.feature_types != nil {
		edges = append(edges, earthquake.EdgeFeatureTypes)
	}
	if m.felt_reports != nil {
		edges = append(edges, earthquake.EdgeFeltReports)
	}
	if m.geometries != nil {
		edges = append(edges, earthquake.EdgeGeometries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeMainEvents:
		ids := make([]ent.Value, 0, len(m.main_events))
		for id := range m.main_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeAssociatedEvents:
		ids := make([]ent.Value, 0, len(m.associated_events))
		for id := range m.associated_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeEventTypes:
		ids := make([]ent.Value, 0, len(m.event_types))
		for id := range m.event_types {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeFeatureTypes:
		ids := make([]ent.Value, 0, len(m.feature_types))
		for id := range m.feature_types {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeFeltReports:
		ids := make([]ent.Value, 0, len(m.felt_reports))
		for id := range m.felt_reports {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.geometries))
		for id := range m.geometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmain_events != nil {
		edges = append(edges, earthquake.EdgeMainEvents)
	}
	if m.removedassociated_events != nil {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.removedevent_types != nil {
		edges = append(edges, earthquake.EdgeEventTypes)
	}
	if m.removedfeature_types != nil {
		edges = append(edges, earthquake.EdgeFeatureTypes)
	}
	if m.removedfelt_reports != nil {
		edges = append(edges, earthquake.EdgeFeltReports)
	}
	if m.removedgeometries != nil {
		edges = append(edges, earthquake.EdgeGeometries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarthquakeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeMainEvents:
		ids := make([]ent.Value, 0, len(m.removedmain_events))
		for id := range m.removedmain_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeAssociatedEvents:
		ids := make([]ent.Value, 0, len(m.removedassociated_events))
		for id := range m.removedassociated_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeEventTypes:
		ids := make([]ent.Value, 0, len(m.removedevent_types))
		for id := range m.removedevent_types {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeFeatureTypes:
		ids := make([]ent.Value, 0, len(m.removedfeature_types))
		for id := range m.removedfeature_types {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeFeltReports:
		ids := make([]ent.Value, 0, len(m.removedfelt_reports))
		for id := range m.removedfelt_reports {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.removedgeometries))
		for id := range m.removedgeometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmain_events {
		edges = append(edges, earthquake.EdgeMainEvents)
	}
	if m.clearedassociated_events {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.clearedevent_types {
		edges = append(edges, earthquake.EdgeEventTypes)
	}
	if m.clearedfeature_types {
		edges = append(edges, earthquake.EdgeFeatureTypes)
	}
	if m.clearedfelt_reports {
		edges = append(edges, earthquake.EdgeFeltReports)
	}
	if m.clearedgeometries {
		edges = append(edges, earthquake.EdgeGeometries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case earthquake.EdgeMainEvents:
		return m.clearedmain_events
	case earthquake.EdgeAssociatedEvents:
		return m.clearedassociated_events
	case earthquake.EdgeEventTypes:
		return m.clearedevent_types
	case earthquake.EdgeFeatureTypes:
		return m.clearedfeature_types
	case earthquake.EdgeFeltReports:
		return m.clearedfelt_reports
	case earthquake.EdgeGeometries:
		return m.clearedgeometries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarthquakeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Earthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case earthquake.EdgeMainEvents:
		m.ResetMainEvents()
		return nil
	case earthquake.EdgeAssociatedEvents:
		m.ResetAssociatedEvents()
		return nil
	case earthquake.EdgeEventTypes:
		m.ResetEventTypes()
		return nil
	case earthquake.EdgeFeatureTypes:
		m.ResetFeatureTypes()
		return nil
	case earthquake.EdgeFeltReports:
		m.ResetFeltReports()
		return nil
	case earthquake.EdgeGeometries:
		m.ResetGeometries()
		return nil
	}
	return fmt.Errorf("unknown Earthquake edge %s", name)
}

// EarthquakeDbMutation represents an operation that mutates the Earthquake_db nodes in the graph.
type EarthquakeDbMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Earthquake_db, error)
	predicates    []predicate.Earthquake_db
}

var _ ent.Mutation = (*EarthquakeDbMutation)(nil)

// earthquakeDbOption allows management of the mutation configuration using functional options.
type earthquakeDbOption func(*EarthquakeDbMutation)

// newEarthquakeDbMutation creates new mutation for the Earthquake_db entity.
func newEarthquakeDbMutation(c config, op Op, opts ...earthquakeDbOption) *EarthquakeDbMutation {
	m := &EarthquakeDbMutation{
		config:        c,
		op:            op,
		typ:           TypeEarthquakeDb,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarthquake_dbID sets the ID field of the mutation.
func withEarthquake_dbID(id int) earthquakeDbOption {
	return func(m *EarthquakeDbMutation) {
		var (
			err   error
			once  sync.Once
			value *Earthquake_db
		)
		m.oldValue = func(ctx context.Context) (*Earthquake_db, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Earthquake_db.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarthquake_db sets the old Earthquake_db of the mutation.
func withEarthquake_db(node *Earthquake_db) earthquakeDbOption {
	return func(m *EarthquakeDbMutation) {
		m.oldValue = func(context.Context) (*Earthquake_db, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarthquakeDbMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarthquakeDbMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarthquakeDbMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarthquakeDbMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Earthquake_db.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the EarthquakeDbMutation builder.
func (m *EarthquakeDbMutation) Where(ps ...predicate.Earthquake_db) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarthquakeDbMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarthquakeDbMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Earthquake_db, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarthquakeDbMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarthquakeDbMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Earthquake_db).
func (m *EarthquakeDbMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarthquakeDbMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarthquakeDbMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarthquakeDbMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Earthquake_db field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeDbMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Earthquake_db field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarthquakeDbMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarthquakeDbMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeDbMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Earthquake_db numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarthquakeDbMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarthquakeDbMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarthquakeDbMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Earthquake_db nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarthquakeDbMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Earthquake_db field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarthquakeDbMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarthquakeDbMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarthquakeDbMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarthquakeDbMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarthquakeDbMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarthquakeDbMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarthquakeDbMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Earthquake_db unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarthquakeDbMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Earthquake_db edge %s", name)
}

// EventTypeMutation represents an operation that mutates the EventType nodes in the graph.
type EventTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	types             *string
	clearedFields     map[string]struct{}
	earthquake        *int32
	clearedearthquake bool
	done              bool
	oldValue          func(context.Context) (*EventType, error)
	predicates        []predicate.EventType
}

var _ ent.Mutation = (*EventTypeMutation)(nil)

// eventtypeOption allows management of the mutation configuration using functional options.
type eventtypeOption func(*EventTypeMutation)

// newEventTypeMutation creates new mutation for the EventType entity.
func newEventTypeMutation(c config, op Op, opts ...eventtypeOption) *EventTypeMutation {
	m := &EventTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEventType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventTypeID sets the ID field of the mutation.
func withEventTypeID(id int32) eventtypeOption {
	return func(m *EventTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EventType
		)
		m.oldValue = func(ctx context.Context) (*EventType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventType sets the old EventType of the mutation.
func withEventType(node *EventType) eventtypeOption {
	return func(m *EventTypeMutation) {
		m.oldValue = func(context.Context) (*EventType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventType entities.
func (m *EventTypeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventTypeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventTypeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *EventTypeMutation) SetEarthquakeID(i int32) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *EventTypeMutation) EarthquakeID() (r int32, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the EventType entity.
// If the EventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventTypeMutation) OldEarthquakeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *EventTypeMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[eventtype.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *EventTypeMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[eventtype.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *EventTypeMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, eventtype.FieldEarthquakeID)
}

// SetTypes sets the "types" field.
func (m *EventTypeMutation) SetTypes(s string) {
	m.types = &s
}

// Types returns the value of the "types" field in the mutation.
func (m *EventTypeMutation) Types() (r string, exists bool) {
	v := m.types
	if v == nil {
		return
	}
	return *v, true
}

// OldTypes returns the old "types" field's value of the EventType entity.
// If the EventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventTypeMutation) OldTypes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypes: %w", err)
	}
	return oldValue.Types, nil
}

// ClearTypes clears the value of the "types" field.
func (m *EventTypeMutation) ClearTypes() {
	m.types = nil
	m.clearedFields[eventtype.FieldTypes] = struct{}{}
}

// TypesCleared returns if the "types" field was cleared in this mutation.
func (m *EventTypeMutation) TypesCleared() bool {
	_, ok := m.clearedFields[eventtype.FieldTypes]
	return ok
}

// ResetTypes resets all changes to the "types" field.
func (m *EventTypeMutation) ResetTypes() {
	m.types = nil
	delete(m.clearedFields, eventtype.FieldTypes)
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *EventTypeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[eventtype.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *EventTypeMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *EventTypeMutation) EarthquakeIDs() (ids []int32) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *EventTypeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the EventTypeMutation builder.
func (m *EventTypeMutation) Where(ps ...predicate.EventType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventType).
func (m *EventTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.earthquake != nil {
		fields = append(fields, eventtype.FieldEarthquakeID)
	}
	if m.types != nil {
		fields = append(fields, eventtype.FieldTypes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventtype.FieldEarthquakeID:
		return m.EarthquakeID()
	case eventtype.FieldTypes:
		return m.Types()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventtype.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case eventtype.FieldTypes:
		return m.OldTypes(ctx)
	}
	return nil, fmt.Errorf("unknown EventType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventtype.FieldEarthquakeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case eventtype.FieldTypes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypes(v)
		return nil
	}
	return fmt.Errorf("unknown EventType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventTypeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventtype.FieldEarthquakeID) {
		fields = append(fields, eventtype.FieldEarthquakeID)
	}
	if m.FieldCleared(eventtype.FieldTypes) {
		fields = append(fields, eventtype.FieldTypes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventTypeMutation) ClearField(name string) error {
	switch name {
	case eventtype.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	case eventtype.FieldTypes:
		m.ClearTypes()
		return nil
	}
	return fmt.Errorf("unknown EventType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventTypeMutation) ResetField(name string) error {
	switch name {
	case eventtype.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case eventtype.FieldTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown EventType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, eventtype.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventtype.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, eventtype.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case eventtype.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventTypeMutation) ClearEdge(name string) error {
	switch name {
	case eventtype.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown EventType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventTypeMutation) ResetEdge(name string) error {
	switch name {
	case eventtype.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown EventType edge %s", name)
}

// FeatureTypeMutation represents an operation that mutates the FeatureType nodes in the graph.
type FeatureTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	feature_product_type *string
	clearedFields        map[string]struct{}
	earthquake           *int32
	clearedearthquake    bool
	done                 bool
	oldValue             func(context.Context) (*FeatureType, error)
	predicates           []predicate.FeatureType
}

var _ ent.Mutation = (*FeatureTypeMutation)(nil)

// featuretypeOption allows management of the mutation configuration using functional options.
type featuretypeOption func(*FeatureTypeMutation)

// newFeatureTypeMutation creates new mutation for the FeatureType entity.
func newFeatureTypeMutation(c config, op Op, opts ...featuretypeOption) *FeatureTypeMutation {
	m := &FeatureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureTypeID sets the ID field of the mutation.
func withFeatureTypeID(id int32) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureType
		)
		m.oldValue = func(ctx context.Context) (*FeatureType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureType sets the old FeatureType of the mutation.
func withFeatureType(node *FeatureType) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		m.oldValue = func(context.Context) (*FeatureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureType entities.
func (m *FeatureTypeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureTypeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureTypeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *FeatureTypeMutation) SetEarthquakeID(i int32) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *FeatureTypeMutation) EarthquakeID() (r int32, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldEarthquakeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *FeatureTypeMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[featuretype.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *FeatureTypeMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[featuretype.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *FeatureTypeMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, featuretype.FieldEarthquakeID)
}

// SetFeatureProductType sets the "feature_product_type" field.
func (m *FeatureTypeMutation) SetFeatureProductType(s string) {
	m.feature_product_type = &s
}

// FeatureProductType returns the value of the "feature_product_type" field in the mutation.
func (m *FeatureTypeMutation) FeatureProductType() (r string, exists bool) {
	v := m.feature_product_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureProductType returns the old "feature_product_type" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldFeatureProductType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureProductType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureProductType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureProductType: %w", err)
	}
	return oldValue.FeatureProductType, nil
}

// ResetFeatureProductType resets all changes to the "feature_product_type" field.
func (m *FeatureTypeMutation) ResetFeatureProductType() {
	m.feature_product_type = nil
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *FeatureTypeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[featuretype.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *FeatureTypeMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *FeatureTypeMutation) EarthquakeIDs() (ids []int32) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *FeatureTypeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the FeatureTypeMutation builder.
func (m *FeatureTypeMutation) Where(ps ...predicate.FeatureType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureType).
func (m *FeatureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.earthquake != nil {
		fields = append(fields, featuretype.FieldEarthquakeID)
	}
	if m.feature_product_type != nil {
		fields = append(fields, featuretype.FieldFeatureProductType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuretype.FieldEarthquakeID:
		return m.EarthquakeID()
	case featuretype.FieldFeatureProductType:
		return m.FeatureProductType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuretype.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case featuretype.FieldFeatureProductType:
		return m.OldFeatureProductType(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuretype.FieldEarthquakeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case featuretype.FieldFeatureProductType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureProductType(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureTypeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuretype.FieldEarthquakeID) {
		fields = append(fields, featuretype.FieldEarthquakeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ClearField(name string) error {
	switch name {
	case featuretype.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	}
	return fmt.Errorf("unknown FeatureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ResetField(name string) error {
	switch name {
	case featuretype.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case featuretype.FieldFeatureProductType:
		m.ResetFeatureProductType()
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, featuretype.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuretype.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, featuretype.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case featuretype.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureTypeMutation) ClearEdge(name string) error {
	switch name {
	case featuretype.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown FeatureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureTypeMutation) ResetEdge(name string) error {
	switch name {
	case featuretype.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown FeatureType edge %s", name)
}

// FeltReportMutation represents an operation that mutates the FeltReport nodes in the graph.
type FeltReportMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	felt              *int32
	addfelt           *int32
	cdi               *float64
	addcdi            *float64
	mmi               *float64
	addmmi            *float64
	alert             *string
	clearedFields     map[string]struct{}
	earthquake        *int32
	clearedearthquake bool
	done              bool
	oldValue          func(context.Context) (*FeltReport, error)
	predicates        []predicate.FeltReport
}

var _ ent.Mutation = (*FeltReportMutation)(nil)

// feltreportOption allows management of the mutation configuration using functional options.
type feltreportOption func(*FeltReportMutation)

// newFeltReportMutation creates new mutation for the FeltReport entity.
func newFeltReportMutation(c config, op Op, opts ...feltreportOption) *FeltReportMutation {
	m := &FeltReportMutation{
		config:        c,
		op:            op,
		typ:           TypeFeltReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeltReportID sets the ID field of the mutation.
func withFeltReportID(id int32) feltreportOption {
	return func(m *FeltReportMutation) {
		var (
			err   error
			once  sync.Once
			value *FeltReport
		)
		m.oldValue = func(ctx context.Context) (*FeltReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeltReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeltReport sets the old FeltReport of the mutation.
func withFeltReport(node *FeltReport) feltreportOption {
	return func(m *FeltReportMutation) {
		m.oldValue = func(context.Context) (*FeltReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeltReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeltReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeltReport entities.
func (m *FeltReportMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeltReportMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeltReportMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeltReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *FeltReportMutation) SetEarthquakeID(i int32) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *FeltReportMutation) EarthquakeID() (r int32, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the FeltReport entity.
// If the FeltReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeltReportMutation) OldEarthquakeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *FeltReportMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[feltreport.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *FeltReportMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[feltreport.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *FeltReportMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, feltreport.FieldEarthquakeID)
}

// SetFelt sets the "felt" field.
func (m *FeltReportMutation) SetFelt(i int32) {
	m.felt = &i
	m.addfelt = nil
}

// Felt returns the value of the "felt" field in the mutation.
func (m *FeltReportMutation) Felt() (r int32, exists bool) {
	v := m.felt
	if v == nil {
		return
	}
	return *v, true
}

// OldFelt returns the old "felt" field's value of the FeltReport entity.
// If the FeltReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeltReportMutation) OldFelt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFelt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFelt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFelt: %w", err)
	}
	return oldValue.Felt, nil
}

// AddFelt adds i to the "felt" field.
func (m *FeltReportMutation) AddFelt(i int32) {
	if m.addfelt != nil {
		*m.addfelt += i
	} else {
		m.addfelt = &i
	}
}

// AddedFelt returns the value that was added to the "felt" field in this mutation.
func (m *FeltReportMutation) AddedFelt() (r int32, exists bool) {
	v := m.addfelt
	if v == nil {
		return
	}
	return *v, true
}

// ClearFelt clears the value of the "felt" field.
func (m *FeltReportMutation) ClearFelt() {
	m.felt = nil
	m.addfelt = nil
	m.clearedFields[feltreport.FieldFelt] = struct{}{}
}

// FeltCleared returns if the "felt" field was cleared in this mutation.
func (m *FeltReportMutation) FeltCleared() bool {
	_, ok := m.clearedFields[feltreport.FieldFelt]
	return ok
}

// ResetFelt resets all changes to the "felt" field.
func (m *FeltReportMutation) ResetFelt() {
	m.felt = nil
	m.addfelt = nil
	delete(m.clearedFields, feltreport.FieldFelt)
}

// SetCdi sets the "cdi" field.
func (m *FeltReportMutation) SetCdi(f float64) {
	m.cdi = &f
	m.addcdi = nil
}

// Cdi returns the value of the "cdi" field in the mutation.
func (m *FeltReportMutation) Cdi() (r float64, exists bool) {
	v := m.cdi
	if v == nil {
		return
	}
	return *v, true
}

// OldCdi returns the old "cdi" field's value of the FeltReport entity.
// If the FeltReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeltReportMutation) OldCdi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdi: %w", err)
	}
	return oldValue.Cdi, nil
}

// AddCdi adds f to the "cdi" field.
func (m *FeltReportMutation) AddCdi(f float64) {
	if m.addcdi != nil {
		*m.addcdi += f
	} else {
		m.addcdi = &f
	}
}

// AddedCdi returns the value that was added to the "cdi" field in this mutation.
func (m *FeltReportMutation) AddedCdi() (r float64, exists bool) {
	v := m.addcdi
	if v == nil {
		return
	}
	return *v, true
}

// ClearCdi clears the value of the "cdi" field.
func (m *FeltReportMutation) ClearCdi() {
	m.cdi = nil
	m.addcdi = nil
	m.clearedFields[feltreport.FieldCdi] = struct{}{}
}

// CdiCleared returns if the "cdi" field was cleared in this mutation.
func (m *FeltReportMutation) CdiCleared() bool {
	_, ok := m.clearedFields[feltreport.FieldCdi]
	return ok
}

// ResetCdi resets all changes to the "cdi" field.
func (m *FeltReportMutation) ResetCdi() {
	m.cdi = nil
	m.addcdi = nil
	delete(m.clearedFields, feltreport.FieldCdi)
}

// SetMmi sets the "mmi" field.
func (m *FeltReportMutation) SetMmi(f float64) {
	m.mmi = &f
	m.addmmi = nil
}

// Mmi returns the value of the "mmi" field in the mutation.
func (m *FeltReportMutation) Mmi() (r float64, exists bool) {
	v := m.mmi
	if v == nil {
		return
	}
	return *v, true
}

// OldMmi returns the old "mmi" field's value of the FeltReport entity.
// If the FeltReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeltReportMutation) OldMmi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMmi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMmi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMmi: %w", err)
	}
	return oldValue.Mmi, nil
}

// AddMmi adds f to the "mmi" field.
func (m *FeltReportMutation) AddMmi(f float64) {
	if m.addmmi != nil {
		*m.addmmi += f
	} else {
		m.addmmi = &f
	}
}

// AddedMmi returns the value that was added to the "mmi" field in this mutation.
func (m *FeltReportMutation) AddedMmi() (r float64, exists bool) {
	v := m.addmmi
	if v == nil {
		return
	}
	return *v, true
}

// ClearMmi clears the value of the "mmi" field.
func (m *FeltReportMutation) ClearMmi() {
	m.mmi = nil
	m.addmmi = nil
	m.clearedFields[feltreport.FieldMmi] = struct{}{}
}

// MmiCleared returns if the "mmi" field was cleared in this mutation.
func (m *FeltReportMutation) MmiCleared() bool {
	_, ok := m.clearedFields[feltreport.FieldMmi]
	return ok
}

// ResetMmi resets all changes to the "mmi" field.
func (m *FeltReportMutation) ResetMmi() {
	m.mmi = nil
	m.addmmi = nil
	delete(m.clearedFields, feltreport.FieldMmi)
}

// SetAlert sets the "alert" field.
func (m *FeltReportMutation) SetAlert(s string) {
	m.alert = &s
}

// Alert returns the value of the "alert" field in the mutation.
func (m *FeltReportMutation) Alert() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlert returns the old "alert" field's value of the FeltReport entity.
// If the FeltReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeltReportMutation) OldAlert(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlert: %w", err)
	}
	return oldValue.Alert, nil
}

// ClearAlert clears the value of the "alert" field.
func (m *FeltReportMutation) ClearAlert() {
	m.alert = nil
	m.clearedFields[feltreport.FieldAlert] = struct{}{}
}

// AlertCleared returns if the "alert" field was cleared in this mutation.
func (m *FeltReportMutation) AlertCleared() bool {
	_, ok := m.clearedFields[feltreport.FieldAlert]
	return ok
}

// ResetAlert resets all changes to the "alert" field.
func (m *FeltReportMutation) ResetAlert() {
	m.alert = nil
	delete(m.clearedFields, feltreport.FieldAlert)
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *FeltReportMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[feltreport.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *FeltReportMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *FeltReportMutation) EarthquakeIDs() (ids []int32) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *FeltReportMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the FeltReportMutation builder.
func (m *FeltReportMutation) Where(ps ...predicate.FeltReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeltReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeltReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeltReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeltReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeltReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeltReport).
func (m *FeltReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeltReportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.earthquake != nil {
		fields = append(fields, feltreport.FieldEarthquakeID)
	}
	if m.felt != nil {
		fields = append(fields, feltreport.FieldFelt)
	}
	if m.cdi != nil {
		fields = append(fields, feltreport.FieldCdi)
	}
	if m.mmi != nil {
		fields = append(fields, feltreport.FieldMmi)
	}
	if m.alert != nil {
		fields = append(fields, feltreport.FieldAlert)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeltReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feltreport.FieldEarthquakeID:
		return m.EarthquakeID()
	case feltreport.FieldFelt:
		return m.Felt()
	case feltreport.FieldCdi:
		return m.Cdi()
	case feltreport.FieldMmi:
		return m.Mmi()
	case feltreport.FieldAlert:
		return m.Alert()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeltReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feltreport.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case feltreport.FieldFelt:
		return m.OldFelt(ctx)
	case feltreport.FieldCdi:
		return m.OldCdi(ctx)
	case feltreport.FieldMmi:
		return m.OldMmi(ctx)
	case feltreport.FieldAlert:
		return m.OldAlert(ctx)
	}
	return nil, fmt.Errorf("unknown FeltReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeltReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feltreport.FieldEarthquakeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case feltreport.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFelt(v)
		return nil
	case feltreport.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdi(v)
		return nil
	case feltreport.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMmi(v)
		return nil
	case feltreport.FieldAlert:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlert(v)
		return nil
	}
	return fmt.Errorf("unknown FeltReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeltReportMutation) AddedFields() []string {
	var fields []string
	if m.addfelt != nil {
		fields = append(fields, feltreport.FieldFelt)
	}
	if m.addcdi != nil {
		fields = append(fields, feltreport.FieldCdi)
	}
	if m.addmmi != nil {
		fields = append(fields, feltreport.FieldMmi)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeltReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feltreport.FieldFelt:
		return m.AddedFelt()
	case feltreport.FieldCdi:
		return m.AddedCdi()
	case feltreport.FieldMmi:
		return m.AddedMmi()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeltReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feltreport.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFelt(v)
		return nil
	case feltreport.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdi(v)
		return nil
	case feltreport.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMmi(v)
		return nil
	}
	return fmt.Errorf("unknown FeltReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeltReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feltreport.FieldEarthquakeID) {
		fields = append(fields, feltreport.FieldEarthquakeID)
	}
	if m.FieldCleared(feltreport.FieldFelt) {
		fields = append(fields, feltreport.FieldFelt)
	}
	if m.FieldCleared(feltreport.FieldCdi) {
		fields = append(fields, feltreport.FieldCdi)
	}
	if m.FieldCleared(feltreport.FieldMmi) {
		fields = append(fields, feltreport.FieldMmi)
	}
	if m.FieldCleared(feltreport.FieldAlert) {
		fields = append(fields, feltreport.FieldAlert)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeltReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeltReportMutation) ClearField(name string) error {
	switch name {
	case feltreport.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	case feltreport.FieldFelt:
		m.ClearFelt()
		return nil
	case feltreport.FieldCdi:
		m.ClearCdi()
		return nil
	case feltreport.FieldMmi:
		m.ClearMmi()
		return nil
	case feltreport.FieldAlert:
		m.ClearAlert()
		return nil
	}
	return fmt.Errorf("unknown FeltReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeltReportMutation) ResetField(name string) error {
	switch name {
	case feltreport.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case feltreport.FieldFelt:
		m.ResetFelt()
		return nil
	case feltreport.FieldCdi:
		m.ResetCdi()
		return nil
	case feltreport.FieldMmi:
		m.ResetMmi()
		return nil
	case feltreport.FieldAlert:
		m.ResetAlert()
		return nil
	}
	return fmt.Errorf("unknown FeltReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeltReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, feltreport.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeltReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feltreport.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeltReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeltReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeltReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, feltreport.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeltReportMutation) EdgeCleared(name string) bool {
	switch name {
	case feltreport.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeltReportMutation) ClearEdge(name string) error {
	switch name {
	case feltreport.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown FeltReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeltReportMutation) ResetEdge(name string) error {
	switch name {
	case feltreport.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown FeltReport edge %s", name)
}

// GeometryMutation represents an operation that mutates the Geometry nodes in the graph.
type GeometryMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	longitude         *float64
	addlongitude      *float64
	latitude          *float64
	addlatitude       *float64
	depth             *float64
	adddepth          *float64
	place             *string
	clearedFields     map[string]struct{}
	earthquake        *int32
	clearedearthquake bool
	done              bool
	oldValue          func(context.Context) (*Geometry, error)
	predicates        []predicate.Geometry
}

var _ ent.Mutation = (*GeometryMutation)(nil)

// geometryOption allows management of the mutation configuration using functional options.
type geometryOption func(*GeometryMutation)

// newGeometryMutation creates new mutation for the Geometry entity.
func newGeometryMutation(c config, op Op, opts ...geometryOption) *GeometryMutation {
	m := &GeometryMutation{
		config:        c,
		op:            op,
		typ:           TypeGeometry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeometryID sets the ID field of the mutation.
func withGeometryID(id int32) geometryOption {
	return func(m *GeometryMutation) {
		var (
			err   error
			once  sync.Once
			value *Geometry
		)
		m.oldValue = func(ctx context.Context) (*Geometry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Geometry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeometry sets the old Geometry of the mutation.
func withGeometry(node *Geometry) geometryOption {
	return func(m *GeometryMutation) {
		m.oldValue = func(context.Context) (*Geometry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeometryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeometryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Geometry entities.
func (m *GeometryMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeometryMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeometryMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Geometry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *GeometryMutation) SetEarthquakeID(i int32) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *GeometryMutation) EarthquakeID() (r int32, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldEarthquakeID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *GeometryMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[geometry.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *GeometryMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[geometry.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *GeometryMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, geometry.FieldEarthquakeID)
}

// SetLongitude sets the "longitude" field.
func (m *GeometryMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *GeometryMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *GeometryMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *GeometryMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *GeometryMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *GeometryMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *GeometryMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *GeometryMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *GeometryMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *GeometryMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetDepth sets the "depth" field.
func (m *GeometryMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *GeometryMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *GeometryMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *GeometryMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *GeometryMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// SetPlace sets the "place" field.
func (m *GeometryMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *GeometryMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *GeometryMutation) ResetPlace() {
	m.place = nil
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *GeometryMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[geometry.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *GeometryMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *GeometryMutation) EarthquakeIDs() (ids []int32) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *GeometryMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the GeometryMutation builder.
func (m *GeometryMutation) Where(ps ...predicate.Geometry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeometryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeometryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Geometry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeometryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeometryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Geometry).
func (m *GeometryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeometryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.earthquake != nil {
		fields = append(fields, geometry.FieldEarthquakeID)
	}
	if m.longitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.depth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	if m.place != nil {
		fields = append(fields, geometry.FieldPlace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeometryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldEarthquakeID:
		return m.EarthquakeID()
	case geometry.FieldLongitude:
		return m.Longitude()
	case geometry.FieldLatitude:
		return m.Latitude()
	case geometry.FieldDepth:
		return m.Depth()
	case geometry.FieldPlace:
		return m.Place()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeometryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case geometry.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case geometry.FieldLongitude:
		return m.OldLongitude(ctx)
	case geometry.FieldLatitude:
		return m.OldLatitude(ctx)
	case geometry.FieldDepth:
		return m.OldDepth(ctx)
	case geometry.FieldPlace:
		return m.OldPlace(ctx)
	}
	return nil, fmt.Errorf("unknown Geometry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldEarthquakeID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case geometry.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeometryMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.adddepth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeometryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldLongitude:
		return m.AddedLongitude()
	case geometry.FieldLatitude:
		return m.AddedLatitude()
	case geometry.FieldDepth:
		return m.AddedDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeometryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(geometry.FieldEarthquakeID) {
		fields = append(fields, geometry.FieldEarthquakeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeometryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeometryMutation) ClearField(name string) error {
	switch name {
	case geometry.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	}
	return fmt.Errorf("unknown Geometry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeometryMutation) ResetField(name string) error {
	switch name {
	case geometry.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case geometry.FieldLongitude:
		m.ResetLongitude()
		return nil
	case geometry.FieldLatitude:
		m.ResetLatitude()
		return nil
	case geometry.FieldDepth:
		m.ResetDepth()
		return nil
	case geometry.FieldPlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeometryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, geometry.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeometryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case geometry.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeometryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeometryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeometryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, geometry.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeometryMutation) EdgeCleared(name string) bool {
	switch name {
	case geometry.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeometryMutation) ClearEdge(name string) error {
	switch name {
	case geometry.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown Geometry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeometryMutation) ResetEdge(name string) error {
	switch name {
	case geometry.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown Geometry edge %s", name)
}

// SchemaMigrationMutation represents an operation that mutates the SchemaMigration nodes in the graph.
type SchemaMigrationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	dirty         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SchemaMigration, error)
	predicates    []predicate.SchemaMigration
}

var _ ent.Mutation = (*SchemaMigrationMutation)(nil)

// schemamigrationOption allows management of the mutation configuration using functional options.
type schemamigrationOption func(*SchemaMigrationMutation)

// newSchemaMigrationMutation creates new mutation for the SchemaMigration entity.
func newSchemaMigrationMutation(c config, op Op, opts ...schemamigrationOption) *SchemaMigrationMutation {
	m := &SchemaMigrationMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaMigration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaMigrationID sets the ID field of the mutation.
func withSchemaMigrationID(id int) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaMigration
		)
		m.oldValue = func(ctx context.Context) (*SchemaMigration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaMigration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaMigration sets the old SchemaMigration of the mutation.
func withSchemaMigration(node *SchemaMigration) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		m.oldValue = func(context.Context) (*SchemaMigration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaMigrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaMigrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaMigration entities.
func (m *SchemaMigrationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaMigrationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaMigrationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaMigration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDirty sets the "dirty" field.
func (m *SchemaMigrationMutation) SetDirty(b bool) {
	m.dirty = &b
}

// Dirty returns the value of the "dirty" field in the mutation.
func (m *SchemaMigrationMutation) Dirty() (r bool, exists bool) {
	v := m.dirty
	if v == nil {
		return
	}
	return *v, true
}

// OldDirty returns the old "dirty" field's value of the SchemaMigration entity.
// If the SchemaMigration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaMigrationMutation) OldDirty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirty: %w", err)
	}
	return oldValue.Dirty, nil
}

// ResetDirty resets all changes to the "dirty" field.
func (m *SchemaMigrationMutation) ResetDirty() {
	m.dirty = nil
}

// Where appends a list predicates to the SchemaMigrationMutation builder.
func (m *SchemaMigrationMutation) Where(ps ...predicate.SchemaMigration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaMigrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaMigrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaMigration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaMigrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaMigrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaMigration).
func (m *SchemaMigrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaMigrationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.dirty != nil {
		fields = append(fields, schemamigration.FieldDirty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaMigrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemamigration.FieldDirty:
		return m.Dirty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaMigrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemamigration.FieldDirty:
		return m.OldDirty(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaMigration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemamigration.FieldDirty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirty(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaMigrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaMigrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemaMigration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaMigrationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaMigrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SchemaMigration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ResetField(name string) error {
	switch name {
	case schemamigration.FieldDirty:
		m.ResetDirty()
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaMigrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaMigrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaMigrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaMigrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaMigrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaMigrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaMigrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaMigrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration edge %s", name)
}
