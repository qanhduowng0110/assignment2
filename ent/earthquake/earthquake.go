// Code generated by ent, DO NOT EDIT.

package earthquake

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the earthquake type in the database.
	Label = "earthquake"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldFeatureID holds the string denoting the feature_id field in the database.
	FieldFeatureID = "feature_id"
	// FieldMagnitude holds the string denoting the magnitude field in the database.
	FieldMagnitude = "magnitude"
	// FieldOccurTime holds the string denoting the occur_time field in the database.
	FieldOccurTime = "occur_time"
	// FieldUpdateTime holds the string denoting the update_time field in the database.
	FieldUpdateTime = "update_time"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldDetailURL holds the string denoting the detail_url field in the database.
	FieldDetailURL = "detail_url"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldTsunami holds the string denoting the tsunami field in the database.
	FieldTsunami = "tsunami"
	// FieldSig holds the string denoting the sig field in the database.
	FieldSig = "sig"
	// FieldNet holds the string denoting the net field in the database.
	FieldNet = "net"
	// FieldCode holds the string denoting the code field in the database.
	FieldCode = "code"
	// FieldNst holds the string denoting the nst field in the database.
	FieldNst = "nst"
	// FieldDmin holds the string denoting the dmin field in the database.
	FieldDmin = "dmin"
	// FieldRms holds the string denoting the rms field in the database.
	FieldRms = "rms"
	// FieldGap holds the string denoting the gap field in the database.
	FieldGap = "gap"
	// FieldMagType holds the string denoting the mag_type field in the database.
	FieldMagType = "mag_type"
	// FieldEarthquakeType holds the string denoting the earthquake_type field in the database.
	FieldEarthquakeType = "earthquake_type"
	// EdgeMainEvents holds the string denoting the main_events edge name in mutations.
	EdgeMainEvents = "main_events"
	// EdgeAssociatedEvents holds the string denoting the associated_events edge name in mutations.
	EdgeAssociatedEvents = "associated_events"
	// EdgeEventTypes holds the string denoting the event_types edge name in mutations.
	EdgeEventTypes = "event_types"
	// EdgeFeatureTypes holds the string denoting the feature_types edge name in mutations.
	EdgeFeatureTypes = "feature_types"
	// EdgeFeltReports holds the string denoting the felt_reports edge name in mutations.
	EdgeFeltReports = "felt_reports"
	// EdgeGeometries holds the string denoting the geometries edge name in mutations.
	EdgeGeometries = "geometries"
	// Table holds the table name of the earthquake in the database.
	Table = "Earthquakes"
	// MainEventsTable is the table that holds the main_events relation/edge.
	MainEventsTable = "Associated_events"
	// MainEventsInverseTable is the table name for the AssociatedEvent entity.
	// It exists in this package in order to avoid circular dependency with the "associatedevent" package.
	MainEventsInverseTable = "Associated_events"
	// MainEventsColumn is the table column denoting the main_events relation/edge.
	MainEventsColumn = "earthquake_id"
	// AssociatedEventsTable is the table that holds the associated_events relation/edge.
	AssociatedEventsTable = "Associated_events"
	// AssociatedEventsInverseTable is the table name for the AssociatedEvent entity.
	// It exists in this package in order to avoid circular dependency with the "associatedevent" package.
	AssociatedEventsInverseTable = "Associated_events"
	// AssociatedEventsColumn is the table column denoting the associated_events relation/edge.
	AssociatedEventsColumn = "associate_id"
	// EventTypesTable is the table that holds the event_types relation/edge.
	EventTypesTable = "Event_types"
	// EventTypesInverseTable is the table name for the EventType entity.
	// It exists in this package in order to avoid circular dependency with the "eventtype" package.
	EventTypesInverseTable = "Event_types"
	// EventTypesColumn is the table column denoting the event_types relation/edge.
	EventTypesColumn = "earthquake_id"
	// FeatureTypesTable is the table that holds the feature_types relation/edge.
	FeatureTypesTable = "Feature_types"
	// FeatureTypesInverseTable is the table name for the FeatureType entity.
	// It exists in this package in order to avoid circular dependency with the "featuretype" package.
	FeatureTypesInverseTable = "Feature_types"
	// FeatureTypesColumn is the table column denoting the feature_types relation/edge.
	FeatureTypesColumn = "earthquake_id"
	// FeltReportsTable is the table that holds the felt_reports relation/edge.
	FeltReportsTable = "Felt_reports"
	// FeltReportsInverseTable is the table name for the FeltReport entity.
	// It exists in this package in order to avoid circular dependency with the "feltreport" package.
	FeltReportsInverseTable = "Felt_reports"
	// FeltReportsColumn is the table column denoting the felt_reports relation/edge.
	FeltReportsColumn = "earthquake_id"
	// GeometriesTable is the table that holds the geometries relation/edge.
	GeometriesTable = "Geometry"
	// GeometriesInverseTable is the table name for the Geometry entity.
	// It exists in this package in order to avoid circular dependency with the "geometry" package.
	GeometriesInverseTable = "Geometry"
	// GeometriesColumn is the table column denoting the geometries relation/edge.
	GeometriesColumn = "earthquake_id"
)

// Columns holds all SQL columns for earthquake fields.
var Columns = []string{
	FieldID,
	FieldFeatureID,
	FieldMagnitude,
	FieldOccurTime,
	FieldUpdateTime,
	FieldURL,
	FieldDetailURL,
	FieldStatus,
	FieldTsunami,
	FieldSig,
	FieldNet,
	FieldCode,
	FieldNst,
	FieldDmin,
	FieldRms,
	FieldGap,
	FieldMagType,
	FieldEarthquakeType,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the Earthquake queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByFeatureID orders the results by the feature_id field.
func ByFeatureID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFeatureID, opts...).ToFunc()
}

// ByMagnitude orders the results by the magnitude field.
func ByMagnitude(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMagnitude, opts...).ToFunc()
}

// ByOccurTime orders the results by the occur_time field.
func ByOccurTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldOccurTime, opts...).ToFunc()
}

// ByUpdateTime orders the results by the update_time field.
func ByUpdateTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdateTime, opts...).ToFunc()
}

// ByURL orders the results by the url field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByDetailURL orders the results by the detail_url field.
func ByDetailURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDetailURL, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByTsunami orders the results by the tsunami field.
func ByTsunami(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTsunami, opts...).ToFunc()
}

// BySig orders the results by the sig field.
func BySig(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSig, opts...).ToFunc()
}

// ByNet orders the results by the net field.
func ByNet(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNet, opts...).ToFunc()
}

// ByCode orders the results by the code field.
func ByCode(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCode, opts...).ToFunc()
}

// ByNst orders the results by the nst field.
func ByNst(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNst, opts...).ToFunc()
}

// ByDmin orders the results by the dmin field.
func ByDmin(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDmin, opts...).ToFunc()
}

// ByRms orders the results by the rms field.
func ByRms(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRms, opts...).ToFunc()
}

// ByGap orders the results by the gap field.
func ByGap(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGap, opts...).ToFunc()
}

// ByMagType orders the results by the mag_type field.
func ByMagType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMagType, opts...).ToFunc()
}

// ByEarthquakeType orders the results by the earthquake_type field.
func ByEarthquakeType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEarthquakeType, opts...).ToFunc()
}

// ByMainEventsCount orders the results by main_events count.
func ByMainEventsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newMainEventsStep(), opts...)
	}
}

// ByMainEvents orders the results by main_events terms.
func ByMainEvents(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMainEventsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAssociatedEventsCount orders the results by associated_events count.
func ByAssociatedEventsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAssociatedEventsStep(), opts...)
	}
}

// ByAssociatedEvents orders the results by associated_events terms.
func ByAssociatedEvents(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAssociatedEventsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByEventTypesCount orders the results by event_types count.
func ByEventTypesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newEventTypesStep(), opts...)
	}
}

// ByEventTypes orders the results by event_types terms.
func ByEventTypes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEventTypesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFeatureTypesCount orders the results by feature_types count.
func ByFeatureTypesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFeatureTypesStep(), opts...)
	}
}

// ByFeatureTypes orders the results by feature_types terms.
func ByFeatureTypes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFeatureTypesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFeltReportsCount orders the results by felt_reports count.
func ByFeltReportsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFeltReportsStep(), opts...)
	}
}

// ByFeltReports orders the results by felt_reports terms.
func ByFeltReports(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFeltReportsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByGeometriesCount orders the results by geometries count.
func ByGeometriesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newGeometriesStep(), opts...)
	}
}

// ByGeometries orders the results by geometries terms.
func ByGeometries(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newGeometriesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newMainEventsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MainEventsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, MainEventsTable, MainEventsColumn),
	)
}
func newAssociatedEventsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AssociatedEventsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AssociatedEventsTable, AssociatedEventsColumn),
	)
}
func newEventTypesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EventTypesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, EventTypesTable, EventTypesColumn),
	)
}
func newFeatureTypesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FeatureTypesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FeatureTypesTable, FeatureTypesColumn),
	)
}
func newFeltReportsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FeltReportsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FeltReportsTable, FeltReportsColumn),
	)
}
func newGeometriesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(GeometriesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, GeometriesTable, GeometriesColumn),
	)
}
