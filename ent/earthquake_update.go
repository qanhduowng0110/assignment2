// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"entdemo/ent/associatedevent"
	"entdemo/ent/earthquake"
	"entdemo/ent/eventtype"
	"entdemo/ent/featuretype"
	"entdemo/ent/feltreport"
	"entdemo/ent/geometry"
	"entdemo/ent/predicate"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EarthquakeUpdate is the builder for updating Earthquake entities.
type EarthquakeUpdate struct {
	config
	hooks    []Hook
	mutation *EarthquakeMutation
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (eu *EarthquakeUpdate) Where(ps ...predicate.Earthquake) *EarthquakeUpdate {
	eu.mutation.Where(ps...)
	return eu
}

// SetFeatureID sets the "feature_id" field.
func (eu *EarthquakeUpdate) SetFeatureID(s string) *EarthquakeUpdate {
	eu.mutation.SetFeatureID(s)
	return eu
}

// SetNillableFeatureID sets the "feature_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableFeatureID(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetFeatureID(*s)
	}
	return eu
}

// SetMagnitude sets the "magnitude" field.
func (eu *EarthquakeUpdate) SetMagnitude(f float64) *EarthquakeUpdate {
	eu.mutation.ResetMagnitude()
	eu.mutation.SetMagnitude(f)
	return eu
}

// SetNillableMagnitude sets the "magnitude" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMagnitude(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetMagnitude(*f)
	}
	return eu
}

// AddMagnitude adds f to the "magnitude" field.
func (eu *EarthquakeUpdate) AddMagnitude(f float64) *EarthquakeUpdate {
	eu.mutation.AddMagnitude(f)
	return eu
}

// SetOccurTime sets the "occur_time" field.
func (eu *EarthquakeUpdate) SetOccurTime(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetOccurTime(t)
	return eu
}

// SetNillableOccurTime sets the "occur_time" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableOccurTime(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetOccurTime(*t)
	}
	return eu
}

// SetUpdateTime sets the "update_time" field.
func (eu *EarthquakeUpdate) SetUpdateTime(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetUpdateTime(t)
	return eu
}

// SetNillableUpdateTime sets the "update_time" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableUpdateTime(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetUpdateTime(*t)
	}
	return eu
}

// SetURL sets the "url" field.
func (eu *EarthquakeUpdate) SetURL(s string) *EarthquakeUpdate {
	eu.mutation.SetURL(s)
	return eu
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableURL(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetURL(*s)
	}
	return eu
}

// SetDetailURL sets the "detail_url" field.
func (eu *EarthquakeUpdate) SetDetailURL(s string) *EarthquakeUpdate {
	eu.mutation.SetDetailURL(s)
	return eu
}

// SetNillableDetailURL sets the "detail_url" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDetailURL(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetDetailURL(*s)
	}
	return eu
}

// SetStatus sets the "status" field.
func (eu *EarthquakeUpdate) SetStatus(s string) *EarthquakeUpdate {
	eu.mutation.SetStatus(s)
	return eu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableStatus(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetStatus(*s)
	}
	return eu
}

// SetTsunami sets the "tsunami" field.
func (eu *EarthquakeUpdate) SetTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.ResetTsunami()
	eu.mutation.SetTsunami(i)
	return eu
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTsunami(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetTsunami(*i)
	}
	return eu
}

// AddTsunami adds i to the "tsunami" field.
func (eu *EarthquakeUpdate) AddTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.AddTsunami(i)
	return eu
}

// SetSig sets the "sig" field.
func (eu *EarthquakeUpdate) SetSig(i int32) *EarthquakeUpdate {
	eu.mutation.ResetSig()
	eu.mutation.SetSig(i)
	return eu
}

// SetNillableSig sets the "sig" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableSig(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetSig(*i)
	}
	return eu
}

// AddSig adds i to the "sig" field.
func (eu *EarthquakeUpdate) AddSig(i int32) *EarthquakeUpdate {
	eu.mutation.AddSig(i)
	return eu
}

// SetNet sets the "net" field.
func (eu *EarthquakeUpdate) SetNet(s string) *EarthquakeUpdate {
	eu.mutation.SetNet(s)
	return eu
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNet(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetNet(*s)
	}
	return eu
}

// SetCode sets the "code" field.
func (eu *EarthquakeUpdate) SetCode(s string) *EarthquakeUpdate {
	eu.mutation.SetCode(s)
	return eu
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableCode(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetCode(*s)
	}
	return eu
}

// SetNst sets the "nst" field.
func (eu *EarthquakeUpdate) SetNst(i int32) *EarthquakeUpdate {
	eu.mutation.ResetNst()
	eu.mutation.SetNst(i)
	return eu
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNst(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetNst(*i)
	}
	return eu
}

// AddNst adds i to the "nst" field.
func (eu *EarthquakeUpdate) AddNst(i int32) *EarthquakeUpdate {
	eu.mutation.AddNst(i)
	return eu
}

// SetDmin sets the "dmin" field.
func (eu *EarthquakeUpdate) SetDmin(f float64) *EarthquakeUpdate {
	eu.mutation.ResetDmin()
	eu.mutation.SetDmin(f)
	return eu
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDmin(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetDmin(*f)
	}
	return eu
}

// AddDmin adds f to the "dmin" field.
func (eu *EarthquakeUpdate) AddDmin(f float64) *EarthquakeUpdate {
	eu.mutation.AddDmin(f)
	return eu
}

// SetRms sets the "rms" field.
func (eu *EarthquakeUpdate) SetRms(f float64) *EarthquakeUpdate {
	eu.mutation.ResetRms()
	eu.mutation.SetRms(f)
	return eu
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableRms(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetRms(*f)
	}
	return eu
}

// AddRms adds f to the "rms" field.
func (eu *EarthquakeUpdate) AddRms(f float64) *EarthquakeUpdate {
	eu.mutation.AddRms(f)
	return eu
}

// SetGap sets the "gap" field.
func (eu *EarthquakeUpdate) SetGap(f float64) *EarthquakeUpdate {
	eu.mutation.ResetGap()
	eu.mutation.SetGap(f)
	return eu
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableGap(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetGap(*f)
	}
	return eu
}

// AddGap adds f to the "gap" field.
func (eu *EarthquakeUpdate) AddGap(f float64) *EarthquakeUpdate {
	eu.mutation.AddGap(f)
	return eu
}

// SetMagType sets the "mag_type" field.
func (eu *EarthquakeUpdate) SetMagType(s string) *EarthquakeUpdate {
	eu.mutation.SetMagType(s)
	return eu
}

// SetNillableMagType sets the "mag_type" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMagType(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetMagType(*s)
	}
	return eu
}

// SetEarthquakeType sets the "earthquake_type" field.
func (eu *EarthquakeUpdate) SetEarthquakeType(s string) *EarthquakeUpdate {
	eu.mutation.SetEarthquakeType(s)
	return eu
}

// SetNillableEarthquakeType sets the "earthquake_type" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableEarthquakeType(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetEarthquakeType(*s)
	}
	return eu
}

// AddMainEventIDs adds the "main_events" edge to the AssociatedEvent entity by IDs.
func (eu *EarthquakeUpdate) AddMainEventIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddMainEventIDs(ids...)
	return eu
}

// AddMainEvents adds the "main_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) AddMainEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.AddMainEventIDs(ids...)
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by IDs.
func (eu *EarthquakeUpdate) AddAssociatedEventIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddAssociatedEventIDs(ids...)
	return eu
}

// AddAssociatedEvents adds the "associated_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) AddAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.AddAssociatedEventIDs(ids...)
}

// AddEventTypeIDs adds the "event_types" edge to the EventType entity by IDs.
func (eu *EarthquakeUpdate) AddEventTypeIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddEventTypeIDs(ids...)
	return eu
}

// AddEventTypes adds the "event_types" edges to the EventType entity.
func (eu *EarthquakeUpdate) AddEventTypes(e ...*EventType) *EarthquakeUpdate {
	ids := make([]int32, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.AddEventTypeIDs(ids...)
}

// AddFeatureTypeIDs adds the "feature_types" edge to the FeatureType entity by IDs.
func (eu *EarthquakeUpdate) AddFeatureTypeIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddFeatureTypeIDs(ids...)
	return eu
}

// AddFeatureTypes adds the "feature_types" edges to the FeatureType entity.
func (eu *EarthquakeUpdate) AddFeatureTypes(f ...*FeatureType) *EarthquakeUpdate {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.AddFeatureTypeIDs(ids...)
}

// AddFeltReportIDs adds the "felt_reports" edge to the FeltReport entity by IDs.
func (eu *EarthquakeUpdate) AddFeltReportIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddFeltReportIDs(ids...)
	return eu
}

// AddFeltReports adds the "felt_reports" edges to the FeltReport entity.
func (eu *EarthquakeUpdate) AddFeltReports(f ...*FeltReport) *EarthquakeUpdate {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.AddFeltReportIDs(ids...)
}

// AddGeometryIDs adds the "geometries" edge to the Geometry entity by IDs.
func (eu *EarthquakeUpdate) AddGeometryIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.AddGeometryIDs(ids...)
	return eu
}

// AddGeometries adds the "geometries" edges to the Geometry entity.
func (eu *EarthquakeUpdate) AddGeometries(g ...*Geometry) *EarthquakeUpdate {
	ids := make([]int32, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return eu.AddGeometryIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (eu *EarthquakeUpdate) Mutation() *EarthquakeMutation {
	return eu.mutation
}

// ClearMainEvents clears all "main_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) ClearMainEvents() *EarthquakeUpdate {
	eu.mutation.ClearMainEvents()
	return eu
}

// RemoveMainEventIDs removes the "main_events" edge to AssociatedEvent entities by IDs.
func (eu *EarthquakeUpdate) RemoveMainEventIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveMainEventIDs(ids...)
	return eu
}

// RemoveMainEvents removes "main_events" edges to AssociatedEvent entities.
func (eu *EarthquakeUpdate) RemoveMainEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.RemoveMainEventIDs(ids...)
}

// ClearAssociatedEvents clears all "associated_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) ClearAssociatedEvents() *EarthquakeUpdate {
	eu.mutation.ClearAssociatedEvents()
	return eu
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to AssociatedEvent entities by IDs.
func (eu *EarthquakeUpdate) RemoveAssociatedEventIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveAssociatedEventIDs(ids...)
	return eu
}

// RemoveAssociatedEvents removes "associated_events" edges to AssociatedEvent entities.
func (eu *EarthquakeUpdate) RemoveAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.RemoveAssociatedEventIDs(ids...)
}

// ClearEventTypes clears all "event_types" edges to the EventType entity.
func (eu *EarthquakeUpdate) ClearEventTypes() *EarthquakeUpdate {
	eu.mutation.ClearEventTypes()
	return eu
}

// RemoveEventTypeIDs removes the "event_types" edge to EventType entities by IDs.
func (eu *EarthquakeUpdate) RemoveEventTypeIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveEventTypeIDs(ids...)
	return eu
}

// RemoveEventTypes removes "event_types" edges to EventType entities.
func (eu *EarthquakeUpdate) RemoveEventTypes(e ...*EventType) *EarthquakeUpdate {
	ids := make([]int32, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.RemoveEventTypeIDs(ids...)
}

// ClearFeatureTypes clears all "feature_types" edges to the FeatureType entity.
func (eu *EarthquakeUpdate) ClearFeatureTypes() *EarthquakeUpdate {
	eu.mutation.ClearFeatureTypes()
	return eu
}

// RemoveFeatureTypeIDs removes the "feature_types" edge to FeatureType entities by IDs.
func (eu *EarthquakeUpdate) RemoveFeatureTypeIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveFeatureTypeIDs(ids...)
	return eu
}

// RemoveFeatureTypes removes "feature_types" edges to FeatureType entities.
func (eu *EarthquakeUpdate) RemoveFeatureTypes(f ...*FeatureType) *EarthquakeUpdate {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.RemoveFeatureTypeIDs(ids...)
}

// ClearFeltReports clears all "felt_reports" edges to the FeltReport entity.
func (eu *EarthquakeUpdate) ClearFeltReports() *EarthquakeUpdate {
	eu.mutation.ClearFeltReports()
	return eu
}

// RemoveFeltReportIDs removes the "felt_reports" edge to FeltReport entities by IDs.
func (eu *EarthquakeUpdate) RemoveFeltReportIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveFeltReportIDs(ids...)
	return eu
}

// RemoveFeltReports removes "felt_reports" edges to FeltReport entities.
func (eu *EarthquakeUpdate) RemoveFeltReports(f ...*FeltReport) *EarthquakeUpdate {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.RemoveFeltReportIDs(ids...)
}

// ClearGeometries clears all "geometries" edges to the Geometry entity.
func (eu *EarthquakeUpdate) ClearGeometries() *EarthquakeUpdate {
	eu.mutation.ClearGeometries()
	return eu
}

// RemoveGeometryIDs removes the "geometries" edge to Geometry entities by IDs.
func (eu *EarthquakeUpdate) RemoveGeometryIDs(ids ...int32) *EarthquakeUpdate {
	eu.mutation.RemoveGeometryIDs(ids...)
	return eu
}

// RemoveGeometries removes "geometries" edges to Geometry entities.
func (eu *EarthquakeUpdate) RemoveGeometries(g ...*Geometry) *EarthquakeUpdate {
	ids := make([]int32, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return eu.RemoveGeometryIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (eu *EarthquakeUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, eu.sqlSave, eu.mutation, eu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eu *EarthquakeUpdate) SaveX(ctx context.Context) int {
	affected, err := eu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eu *EarthquakeUpdate) Exec(ctx context.Context) error {
	_, err := eu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eu *EarthquakeUpdate) ExecX(ctx context.Context) {
	if err := eu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (eu *EarthquakeUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt32))
	if ps := eu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eu.mutation.FeatureID(); ok {
		_spec.SetField(earthquake.FieldFeatureID, field.TypeString, value)
	}
	if value, ok := eu.mutation.Magnitude(); ok {
		_spec.SetField(earthquake.FieldMagnitude, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedMagnitude(); ok {
		_spec.AddField(earthquake.FieldMagnitude, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.OccurTime(); ok {
		_spec.SetField(earthquake.FieldOccurTime, field.TypeTime, value)
	}
	if value, ok := eu.mutation.UpdateTime(); ok {
		_spec.SetField(earthquake.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := eu.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if value, ok := eu.mutation.DetailURL(); ok {
		_spec.SetField(earthquake.FieldDetailURL, field.TypeString, value)
	}
	if value, ok := eu.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if value, ok := eu.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.Sig(); ok {
		_spec.SetField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedSig(); ok {
		_spec.AddField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if value, ok := eu.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if value, ok := eu.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.MagType(); ok {
		_spec.SetField(earthquake.FieldMagType, field.TypeString, value)
	}
	if value, ok := eu.mutation.EarthquakeType(); ok {
		_spec.SetField(earthquake.FieldEarthquakeType, field.TypeString, value)
	}
	if eu.mutation.MainEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedMainEventsIDs(); len(nodes) > 0 && !eu.mutation.MainEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.MainEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedAssociatedEventsIDs(); len(nodes) > 0 && !eu.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.AssociatedEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.EventTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedEventTypesIDs(); len(nodes) > 0 && !eu.mutation.EventTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.EventTypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.FeatureTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedFeatureTypesIDs(); len(nodes) > 0 && !eu.mutation.FeatureTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.FeatureTypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.FeltReportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedFeltReportsIDs(); len(nodes) > 0 && !eu.mutation.FeltReportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.FeltReportsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.GeometriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedGeometriesIDs(); len(nodes) > 0 && !eu.mutation.GeometriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.GeometriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, eu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	eu.mutation.done = true
	return n, nil
}

// EarthquakeUpdateOne is the builder for updating a single Earthquake entity.
type EarthquakeUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *EarthquakeMutation
}

// SetFeatureID sets the "feature_id" field.
func (euo *EarthquakeUpdateOne) SetFeatureID(s string) *EarthquakeUpdateOne {
	euo.mutation.SetFeatureID(s)
	return euo
}

// SetNillableFeatureID sets the "feature_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableFeatureID(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetFeatureID(*s)
	}
	return euo
}

// SetMagnitude sets the "magnitude" field.
func (euo *EarthquakeUpdateOne) SetMagnitude(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetMagnitude()
	euo.mutation.SetMagnitude(f)
	return euo
}

// SetNillableMagnitude sets the "magnitude" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMagnitude(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetMagnitude(*f)
	}
	return euo
}

// AddMagnitude adds f to the "magnitude" field.
func (euo *EarthquakeUpdateOne) AddMagnitude(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddMagnitude(f)
	return euo
}

// SetOccurTime sets the "occur_time" field.
func (euo *EarthquakeUpdateOne) SetOccurTime(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetOccurTime(t)
	return euo
}

// SetNillableOccurTime sets the "occur_time" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableOccurTime(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetOccurTime(*t)
	}
	return euo
}

// SetUpdateTime sets the "update_time" field.
func (euo *EarthquakeUpdateOne) SetUpdateTime(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetUpdateTime(t)
	return euo
}

// SetNillableUpdateTime sets the "update_time" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableUpdateTime(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetUpdateTime(*t)
	}
	return euo
}

// SetURL sets the "url" field.
func (euo *EarthquakeUpdateOne) SetURL(s string) *EarthquakeUpdateOne {
	euo.mutation.SetURL(s)
	return euo
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableURL(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetURL(*s)
	}
	return euo
}

// SetDetailURL sets the "detail_url" field.
func (euo *EarthquakeUpdateOne) SetDetailURL(s string) *EarthquakeUpdateOne {
	euo.mutation.SetDetailURL(s)
	return euo
}

// SetNillableDetailURL sets the "detail_url" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDetailURL(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetDetailURL(*s)
	}
	return euo
}

// SetStatus sets the "status" field.
func (euo *EarthquakeUpdateOne) SetStatus(s string) *EarthquakeUpdateOne {
	euo.mutation.SetStatus(s)
	return euo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableStatus(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetStatus(*s)
	}
	return euo
}

// SetTsunami sets the "tsunami" field.
func (euo *EarthquakeUpdateOne) SetTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetTsunami()
	euo.mutation.SetTsunami(i)
	return euo
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTsunami(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetTsunami(*i)
	}
	return euo
}

// AddTsunami adds i to the "tsunami" field.
func (euo *EarthquakeUpdateOne) AddTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddTsunami(i)
	return euo
}

// SetSig sets the "sig" field.
func (euo *EarthquakeUpdateOne) SetSig(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetSig()
	euo.mutation.SetSig(i)
	return euo
}

// SetNillableSig sets the "sig" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableSig(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetSig(*i)
	}
	return euo
}

// AddSig adds i to the "sig" field.
func (euo *EarthquakeUpdateOne) AddSig(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddSig(i)
	return euo
}

// SetNet sets the "net" field.
func (euo *EarthquakeUpdateOne) SetNet(s string) *EarthquakeUpdateOne {
	euo.mutation.SetNet(s)
	return euo
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNet(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetNet(*s)
	}
	return euo
}

// SetCode sets the "code" field.
func (euo *EarthquakeUpdateOne) SetCode(s string) *EarthquakeUpdateOne {
	euo.mutation.SetCode(s)
	return euo
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableCode(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetCode(*s)
	}
	return euo
}

// SetNst sets the "nst" field.
func (euo *EarthquakeUpdateOne) SetNst(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetNst()
	euo.mutation.SetNst(i)
	return euo
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNst(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetNst(*i)
	}
	return euo
}

// AddNst adds i to the "nst" field.
func (euo *EarthquakeUpdateOne) AddNst(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddNst(i)
	return euo
}

// SetDmin sets the "dmin" field.
func (euo *EarthquakeUpdateOne) SetDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetDmin()
	euo.mutation.SetDmin(f)
	return euo
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDmin(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetDmin(*f)
	}
	return euo
}

// AddDmin adds f to the "dmin" field.
func (euo *EarthquakeUpdateOne) AddDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddDmin(f)
	return euo
}

// SetRms sets the "rms" field.
func (euo *EarthquakeUpdateOne) SetRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetRms()
	euo.mutation.SetRms(f)
	return euo
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableRms(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetRms(*f)
	}
	return euo
}

// AddRms adds f to the "rms" field.
func (euo *EarthquakeUpdateOne) AddRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddRms(f)
	return euo
}

// SetGap sets the "gap" field.
func (euo *EarthquakeUpdateOne) SetGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetGap()
	euo.mutation.SetGap(f)
	return euo
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableGap(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetGap(*f)
	}
	return euo
}

// AddGap adds f to the "gap" field.
func (euo *EarthquakeUpdateOne) AddGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddGap(f)
	return euo
}

// SetMagType sets the "mag_type" field.
func (euo *EarthquakeUpdateOne) SetMagType(s string) *EarthquakeUpdateOne {
	euo.mutation.SetMagType(s)
	return euo
}

// SetNillableMagType sets the "mag_type" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMagType(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetMagType(*s)
	}
	return euo
}

// SetEarthquakeType sets the "earthquake_type" field.
func (euo *EarthquakeUpdateOne) SetEarthquakeType(s string) *EarthquakeUpdateOne {
	euo.mutation.SetEarthquakeType(s)
	return euo
}

// SetNillableEarthquakeType sets the "earthquake_type" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableEarthquakeType(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetEarthquakeType(*s)
	}
	return euo
}

// AddMainEventIDs adds the "main_events" edge to the AssociatedEvent entity by IDs.
func (euo *EarthquakeUpdateOne) AddMainEventIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddMainEventIDs(ids...)
	return euo
}

// AddMainEvents adds the "main_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) AddMainEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.AddMainEventIDs(ids...)
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by IDs.
func (euo *EarthquakeUpdateOne) AddAssociatedEventIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddAssociatedEventIDs(ids...)
	return euo
}

// AddAssociatedEvents adds the "associated_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) AddAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.AddAssociatedEventIDs(ids...)
}

// AddEventTypeIDs adds the "event_types" edge to the EventType entity by IDs.
func (euo *EarthquakeUpdateOne) AddEventTypeIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddEventTypeIDs(ids...)
	return euo
}

// AddEventTypes adds the "event_types" edges to the EventType entity.
func (euo *EarthquakeUpdateOne) AddEventTypes(e ...*EventType) *EarthquakeUpdateOne {
	ids := make([]int32, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.AddEventTypeIDs(ids...)
}

// AddFeatureTypeIDs adds the "feature_types" edge to the FeatureType entity by IDs.
func (euo *EarthquakeUpdateOne) AddFeatureTypeIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddFeatureTypeIDs(ids...)
	return euo
}

// AddFeatureTypes adds the "feature_types" edges to the FeatureType entity.
func (euo *EarthquakeUpdateOne) AddFeatureTypes(f ...*FeatureType) *EarthquakeUpdateOne {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.AddFeatureTypeIDs(ids...)
}

// AddFeltReportIDs adds the "felt_reports" edge to the FeltReport entity by IDs.
func (euo *EarthquakeUpdateOne) AddFeltReportIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddFeltReportIDs(ids...)
	return euo
}

// AddFeltReports adds the "felt_reports" edges to the FeltReport entity.
func (euo *EarthquakeUpdateOne) AddFeltReports(f ...*FeltReport) *EarthquakeUpdateOne {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.AddFeltReportIDs(ids...)
}

// AddGeometryIDs adds the "geometries" edge to the Geometry entity by IDs.
func (euo *EarthquakeUpdateOne) AddGeometryIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.AddGeometryIDs(ids...)
	return euo
}

// AddGeometries adds the "geometries" edges to the Geometry entity.
func (euo *EarthquakeUpdateOne) AddGeometries(g ...*Geometry) *EarthquakeUpdateOne {
	ids := make([]int32, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return euo.AddGeometryIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (euo *EarthquakeUpdateOne) Mutation() *EarthquakeMutation {
	return euo.mutation
}

// ClearMainEvents clears all "main_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) ClearMainEvents() *EarthquakeUpdateOne {
	euo.mutation.ClearMainEvents()
	return euo
}

// RemoveMainEventIDs removes the "main_events" edge to AssociatedEvent entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveMainEventIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveMainEventIDs(ids...)
	return euo
}

// RemoveMainEvents removes "main_events" edges to AssociatedEvent entities.
func (euo *EarthquakeUpdateOne) RemoveMainEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.RemoveMainEventIDs(ids...)
}

// ClearAssociatedEvents clears all "associated_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) ClearAssociatedEvents() *EarthquakeUpdateOne {
	euo.mutation.ClearAssociatedEvents()
	return euo
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to AssociatedEvent entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveAssociatedEventIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveAssociatedEventIDs(ids...)
	return euo
}

// RemoveAssociatedEvents removes "associated_events" edges to AssociatedEvent entities.
func (euo *EarthquakeUpdateOne) RemoveAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int32, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.RemoveAssociatedEventIDs(ids...)
}

// ClearEventTypes clears all "event_types" edges to the EventType entity.
func (euo *EarthquakeUpdateOne) ClearEventTypes() *EarthquakeUpdateOne {
	euo.mutation.ClearEventTypes()
	return euo
}

// RemoveEventTypeIDs removes the "event_types" edge to EventType entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveEventTypeIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveEventTypeIDs(ids...)
	return euo
}

// RemoveEventTypes removes "event_types" edges to EventType entities.
func (euo *EarthquakeUpdateOne) RemoveEventTypes(e ...*EventType) *EarthquakeUpdateOne {
	ids := make([]int32, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.RemoveEventTypeIDs(ids...)
}

// ClearFeatureTypes clears all "feature_types" edges to the FeatureType entity.
func (euo *EarthquakeUpdateOne) ClearFeatureTypes() *EarthquakeUpdateOne {
	euo.mutation.ClearFeatureTypes()
	return euo
}

// RemoveFeatureTypeIDs removes the "feature_types" edge to FeatureType entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveFeatureTypeIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveFeatureTypeIDs(ids...)
	return euo
}

// RemoveFeatureTypes removes "feature_types" edges to FeatureType entities.
func (euo *EarthquakeUpdateOne) RemoveFeatureTypes(f ...*FeatureType) *EarthquakeUpdateOne {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.RemoveFeatureTypeIDs(ids...)
}

// ClearFeltReports clears all "felt_reports" edges to the FeltReport entity.
func (euo *EarthquakeUpdateOne) ClearFeltReports() *EarthquakeUpdateOne {
	euo.mutation.ClearFeltReports()
	return euo
}

// RemoveFeltReportIDs removes the "felt_reports" edge to FeltReport entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveFeltReportIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveFeltReportIDs(ids...)
	return euo
}

// RemoveFeltReports removes "felt_reports" edges to FeltReport entities.
func (euo *EarthquakeUpdateOne) RemoveFeltReports(f ...*FeltReport) *EarthquakeUpdateOne {
	ids := make([]int32, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.RemoveFeltReportIDs(ids...)
}

// ClearGeometries clears all "geometries" edges to the Geometry entity.
func (euo *EarthquakeUpdateOne) ClearGeometries() *EarthquakeUpdateOne {
	euo.mutation.ClearGeometries()
	return euo
}

// RemoveGeometryIDs removes the "geometries" edge to Geometry entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveGeometryIDs(ids ...int32) *EarthquakeUpdateOne {
	euo.mutation.RemoveGeometryIDs(ids...)
	return euo
}

// RemoveGeometries removes "geometries" edges to Geometry entities.
func (euo *EarthquakeUpdateOne) RemoveGeometries(g ...*Geometry) *EarthquakeUpdateOne {
	ids := make([]int32, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return euo.RemoveGeometryIDs(ids...)
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (euo *EarthquakeUpdateOne) Where(ps ...predicate.Earthquake) *EarthquakeUpdateOne {
	euo.mutation.Where(ps...)
	return euo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (euo *EarthquakeUpdateOne) Select(field string, fields ...string) *EarthquakeUpdateOne {
	euo.fields = append([]string{field}, fields...)
	return euo
}

// Save executes the query and returns the updated Earthquake entity.
func (euo *EarthquakeUpdateOne) Save(ctx context.Context) (*Earthquake, error) {
	return withHooks(ctx, euo.sqlSave, euo.mutation, euo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) SaveX(ctx context.Context) *Earthquake {
	node, err := euo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (euo *EarthquakeUpdateOne) Exec(ctx context.Context) error {
	_, err := euo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) ExecX(ctx context.Context) {
	if err := euo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (euo *EarthquakeUpdateOne) sqlSave(ctx context.Context) (_node *Earthquake, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt32))
	id, ok := euo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Earthquake.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := euo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, earthquake.FieldID)
		for _, f := range fields {
			if !earthquake.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != earthquake.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := euo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := euo.mutation.FeatureID(); ok {
		_spec.SetField(earthquake.FieldFeatureID, field.TypeString, value)
	}
	if value, ok := euo.mutation.Magnitude(); ok {
		_spec.SetField(earthquake.FieldMagnitude, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedMagnitude(); ok {
		_spec.AddField(earthquake.FieldMagnitude, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.OccurTime(); ok {
		_spec.SetField(earthquake.FieldOccurTime, field.TypeTime, value)
	}
	if value, ok := euo.mutation.UpdateTime(); ok {
		_spec.SetField(earthquake.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := euo.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if value, ok := euo.mutation.DetailURL(); ok {
		_spec.SetField(earthquake.FieldDetailURL, field.TypeString, value)
	}
	if value, ok := euo.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if value, ok := euo.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.Sig(); ok {
		_spec.SetField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedSig(); ok {
		_spec.AddField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if value, ok := euo.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if value, ok := euo.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.MagType(); ok {
		_spec.SetField(earthquake.FieldMagType, field.TypeString, value)
	}
	if value, ok := euo.mutation.EarthquakeType(); ok {
		_spec.SetField(earthquake.FieldEarthquakeType, field.TypeString, value)
	}
	if euo.mutation.MainEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedMainEventsIDs(); len(nodes) > 0 && !euo.mutation.MainEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.MainEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.MainEventsTable,
			Columns: []string{earthquake.MainEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedAssociatedEventsIDs(); len(nodes) > 0 && !euo.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.AssociatedEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.EventTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedEventTypesIDs(); len(nodes) > 0 && !euo.mutation.EventTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.EventTypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.EventTypesTable,
			Columns: []string{earthquake.EventTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(eventtype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.FeatureTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedFeatureTypesIDs(); len(nodes) > 0 && !euo.mutation.FeatureTypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.FeatureTypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeatureTypesTable,
			Columns: []string{earthquake.FeatureTypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(featuretype.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.FeltReportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedFeltReportsIDs(); len(nodes) > 0 && !euo.mutation.FeltReportsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.FeltReportsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FeltReportsTable,
			Columns: []string{earthquake.FeltReportsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(feltreport.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.GeometriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedGeometriesIDs(); len(nodes) > 0 && !euo.mutation.GeometriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.GeometriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.GeometriesTable,
			Columns: []string{earthquake.GeometriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt32),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Earthquake{config: euo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, euo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	euo.mutation.done = true
	return _node, nil
}
